@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix qdrant: <https://wikipunk.net/qdrant/> .
@prefix as: <https://www.w3.org/ns/activitystreams#> .
@prefix jsonschema: <https://www.w3.org/2019/wot/json-schema#> .
@prefix schema: <http://schema.org/> .

## Examples

### Create collection
# First - let's create a collection with dot-production metric.
# ```
# curl -X PUT 'http://localhost:6333/collections/test_collection' \
#   -H 'Content-Type: application/json' \
#   --data-raw '{
#     "vectors": {
#       "size": 4,
#       "distance": "Dot"
#     }
#   }'

# ```
# Expected response:
# ```
# {
#     "result": true,
#     "status": "ok",
#     "time": 0.031095451
# }
# ```
# We can ensure that collection was created:
# ```
# curl 'http://localhost:6333/collections/test_collection'
# ```
# Expected response:
# ```
# {
#   "result": {
#     "status": "green",
#     "vectors_count": 0,
#     "segments_count": 5,
#     "disk_data_size": 0,
#     "ram_data_size": 0,
#     "config": {
#       "params": {
#         "vectors": {
#           "size": 4,
#           "distance": "Dot"
#         }
#       },
#       "hnsw_config": {
#         "m": 16,
#         "ef_construct": 100,
#         "full_scan_threshold": 10000
#       },
#       "optimizer_config": {
#         "deleted_threshold": 0.2,
#         "vacuum_min_vector_number": 1000,
#         "max_segment_number": 5,
#         "memmap_threshold": 50000,
#         "indexing_threshold": 20000,
#         "flush_interval_sec": 1
#       },
#       "wal_config": {
#         "wal_capacity_mb": 32,
#         "wal_segments_ahead": 0
#       }
#     }
#   },
#   "status": "ok",
#   "time": 2.1199e-05
# }
# ```

# Add points
# Let's now add vectors with some payload:
# ```
# curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \ -H 'Content-Type: application/json' \ --data-raw '{
#   "points": [
#     {"id": 1, "vector": [0.05, 0.61, 0.76, 0.74], "payload": {"city": "Berlin"}},
#     {"id": 2, "vector": [0.19, 0.81, 0.75, 0.11], "payload": {"city": ["Berlin", "London"] }},
#     {"id": 3, "vector": [0.36, 0.55, 0.47, 0.94], "payload": {"city": ["Berlin", "Moscow"] }},
#     {"id": 4, "vector": [0.18, 0.01, 0.85, 0.80], "payload": {"city": ["London", "Moscow"] }},
#     {"id": 5, "vector": [0.24, 0.18, 0.22, 0.44], "payload": {"count": [0]}},
#     {"id": 6, "vector": [0.35, 0.08, 0.11, 0.44]}
#   ]
# }'
# ```
# Expected response:
# ```
# {
#     "result": {
#         "operation_id": 0,
#         "status": "completed"
#     },
#     "status": "ok",
#     "time": 0.000206061
# }
# ```

# Search with filtering
# Let's start with a basic request:
# ```
# curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \ -H 'Content-Type: application/json' \ --data-raw '{
#     "vector": [0.2,0.1,0.9,0.7],
#     "top": 3
# }'
# ```
# Expected response:
# ```
# {
#     "result": [
#         { "id": 4, "score": 1.362, "payload": null, "version": 0 },
#         { "id": 1, "score": 1.273, "payload": null, "version": 0 },
#         { "id": 3, "score": 1.208, "payload": null, "version": 0 }
#     ],
#     "status": "ok",
#     "time": 0.000055785
# }
# ```
# But result is different if we add a filter:
# ```
# curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \ -H 'Content-Type: application/json' \ --data-raw '{
#     "filter": {
#         "should": [
#             {
#                 "key": "city",
#                 "match": {
#                     "value": "London"
#                 }
#             }
#         ]
#     },
#     "vector": [0.2, 0.1, 0.9, 0.7],
#     "top": 3
# }'
# ```
# Expected response:
# ```
# {
#     "result": [
#         { "id": 4, "score": 1.362, "payload": null, "version": 0 },
#         { "id": 2, "score": 0.871, "payload": null, "version": 0 }
#     ],
#     "status": "ok",
#     "time": 0.000093972
# }
# ```

qdrant: a owl:Ontology ;
  rdfs:label "Qdrant Ontology" .

# AbortTransferOperation
# {"type" "object", "required" ["abort_transfer"], "properties" {"abort_transfer" {"$ref" "#/components/schemas/MoveShard"}}}

qdrant:AbortTransferOperation a jsonschema:ObjectSchema ;
  jsonschema:required ( "abort_transfer" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "abort_transfer" ;
    rdf:type qdrant:MoveShard ;
    ]) .

# AliasDescription
# {"type" "object", "required" ["alias_name" "collection_name"], "properties" {"alias_name" {"type" "string"}, "collection_name" {"type" "string"}}}

qdrant:AliasDescription a jsonschema:ObjectSchema ;
  jsonschema:required ( "alias_name" "collection_name" ) ;
  jsonschema:properties [
    jsonschema:propertyName "alias_name" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    jsonschema:propertyName "collection_name" ;
    rdf:type jsonschema:StringSchema ;
    ] .

# AliasOperations
# {"description" "Group of all the possible operations related to collection aliases", "anyOf" [{"$ref" "#/components/schemas/CreateAliasOperation"} {"$ref" "#/components/schemas/DeleteAliasOperation"} {"$ref" "#/components/schemas/RenameAliasOperation"}]}

qdrant:AliasOperations a jsonschema:DataSchema ;
  jsonschema:anyOf (
    qdrant:CreateAliasOperation
    qdrant:DeleteAliasOperation
    qdrant:RenameAliasOperation
    ) ;
  dcterms:description "Group of all the possible operations related to collection aliases" .

# AnyVariants
# {"anyOf" [{"type" "array", "items" {"type" "string"}} {"type" "array", "items" {"type" "integer", "format" "int64"}}]}

qdrant:AnyVariants a jsonschema:DataSchema ;
  jsonschema:anyOf [ 
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items [ 
      rdf:type "string" ;
      ] , 
      [ 
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items [
        rdf:type jsonschema:IntegerSchema ;
        jsonschema:format "int64" ;
        ] ;
      ] ; 
    ] .

# AppBuildTelemetry
# {"type" "object", "required" ["name" "startup" "version"], "properties" {"name" {"type" "string"}, "version" {"type" "string"}, "features" {"anyOf" [{"$ref" "#/components/schemas/AppFeaturesTelemetry"} {"nullable" true}]}, "system" {"anyOf" [{"$ref" "#/components/schemas/RunningEnvironmentTelemetry"} {"nullable" true}]}, "startup" {"type" "string", "format" "date-time"}}}

qdrant:AppBuildTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "name" "startup" "version" ) ;
  jsonschema:properties [
    jsonschema:propertyName "name" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    jsonschema:propertyName "version" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    jsonschema:propertyName "features" ;
    jsonschema:anyOf (
      qdrant:AppFeaturesTelemetry
      jsonschema:NullSchema
      ) ;
    ], 
    [ 
    jsonschema:propertyName "system" ;
    jsonschema:anyOf (
      qdrant:RunningEnvironmentTelemetry
      jsonschema:NullSchema
      ) ;
    ], 
    [ 
    jsonschema:propertyName "startup" ;
    rdf:type jsonschema:StringSchema ;
    jsonschema:format "date-time" ;
    ] .


# AppFeaturesTelemetry
# {"type" "object", "required" ["debug" "service_debug_feature" "web_feature"], "properties" {"debug" {"type" "boolean"}, "web_feature" {"type" "boolean"}, "service_debug_feature" {"type" "boolean"}}}

qdrant:AppFeaturesTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "debug" "service_debug_feature" "web_feature" ) ;
  jsonschema:properties [
    jsonschema:propertyName "debug" ;
    rdf:type jsonschema:BooleanSchema ;
    ], 
    [ 
    jsonschema:propertyName "service_debug_feature" ;
    rdf:type jsonschema:BooleanSchema ;
    ], 
    [ 
    jsonschema:propertyName "web_feature" ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# Batch
# {"type" "object", "required" ["ids" "vectors"], "properties" {"ids" {"type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "vectors" {"$ref" "#/components/schemas/BatchVectorStruct"}, "payloads" {"type" "array", "items" {"anyOf" [{"$ref" "#/components/schemas/Payload"} {"nullable" true}]}, "nullable" true}}}

qdrant:Batch a jsonschema:ObjectSchema ;
  jsonschema:required ( "ids" "vectors" ) ;
  jsonschema:properties [
    jsonschema:propertyName "ids" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    ], 
    [ 
    jsonschema:propertyName "vectors" ;
    rdf:type qdrant:BatchVectorStruct ;
    ], 
    [ 
    jsonschema:propertyName "payloads" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items [
      jsonschema:anyOf (
        qdrant:Payload
        jsonschema:NullSchema
        ) ;
      ] ;
    ] .

# BatchVectorStruct
# {"anyOf" [{"type" "array", "items" {"type" "array", "items" {"type" "number", "format" "float"}}} {"type" "object", "additionalProperties" {"type" "array", "items" {"type" "array", "items" {"type" "number", "format" "float"}}}}]}

qdrant:BatchVectorStruct a jsonschema:DataSchema ;
  jsonschema:anyOf [ 
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items [ 
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items [
        rdf:type jsonschema:NumberSchema ;
        jsonschema:format "float" ;
        ] ;
      ] ;
    ] , 
    [
    rdf:type jsonschema:ObjectSchema ;
    jsonschema:properties [
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items [ 
        rdf:type jsonschema:ArraySchema ;
        jsonschema:items [
          rdf:type jsonschema:NumberSchema ;
          jsonschema:format "float" ;
          ] ;
        ] ;
      ] ;
    ] .
    
# ChangeAliasesOperation
# {"description" "Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations.", "type" "object", "required" ["actions"], "properties" {"actions" {"type" "array", "items" {"$ref" "#/components/schemas/AliasOperations"}}}}

qdrant:ChangeAliasesOperation a jsonschema:ObjectSchema ;
  dcterms:description "Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations." ;
  jsonschema:required ( "actions" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "actions" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:AliasOperations ;
    ]) .

# ClusterConfigTelemetry
# {"type" "object", "required" ["consensus" "grpc_timeout_ms" "p2p"], "properties" {"grpc_timeout_ms" {"type" "integer", "format" "uint64", "minimum" 0}, "p2p" {"$ref" "#/components/schemas/P2pConfigTelemetry"}, "consensus" {"$ref" "#/components/schemas/ConsensusConfigTelemetry"}}}

qdrant:ClusterConfigTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "consensus" "grpc_timeout_ms" "p2p" ) ;
  jsonschema:properties [
    jsonschema:propertyName "grpc_timeout_ms" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "p2p" ;
    rdf:type qdrant:P2pConfigTelemetry ;
    ], 
    [ 
    jsonschema:propertyName "consensus" ;
    rdf:type qdrant:ConsensusConfigTelemetry ;
    ] .

# ClusterOperations
# {"anyOf" [{"$ref" "#/components/schemas/MoveShardOperation"} {"$ref" "#/components/schemas/ReplicateShardOperation"} {"$ref" "#/components/schemas/AbortTransferOperation"} {"$ref" "#/components/schemas/DropReplicaOperation"}]}

qdrant:ClusterOperations a jsonschema:DataSchema ;
  jsonschema:anyOf ( 
    qdrant:MoveShardOperation
    qdrant:ReplicateShardOperation
    qdrant:AbortTransferOperation
    qdrant:DropReplicaOperation
    ) .

# ClusterStatus
# {"description" "Information about current cluster status and structure", "oneOf" [{"type" "object", "required" ["status"], "properties" {"status" {"type" "string", "enum" ["disabled"]}}} {"description" "Description of enabled cluster", "type" "object", "required" ["consensus_thread_status" "message_send_failures" "peer_id" "peers" "raft_info" "status"], "properties" {"status" {"type" "string", "enum" ["enabled"]}, "peer_id" {"description" "ID of this peer", "type" "integer", "format" "uint64", "minimum" 0}, "peers" {"description" "Peers composition of the cluster with main information", "type" "object", "additionalProperties" {"$ref" "#/components/schemas/PeerInfo"}}, "raft_info" {"$ref" "#/components/schemas/RaftInfo"}, "consensus_thread_status" {"$ref" "#/components/schemas/ConsensusThreadStatus"}, "message_send_failures" {"description" "Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap.", "type" "object", "additionalProperties" {"$ref" "#/components/schemas/MessageSendErrors"}}}}]}

qdrant:ClusterStatus a jsonschema:DataSchema ;
  dcterms:description "Information about current cluster status and structure" ;
  jsonschema:oneOf ( 
    [
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:required ( "status" ) ;
      jsonschema:properties [
        jsonschema:propertyName "status" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:enum ( "disabled" ) ;
        ] ;
      ] 
    [
      dcterms:description "Description of enabled cluster" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:required ( "consensus_thread_status" "message_send_failures" "peer_id" "peers" "raft_info" "status" ) ;
      jsonschema:properties [
        jsonschema:propertyName "status" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:enum ( "enabled" ) ;
        ] , 
        [ 
        jsonschema:propertyName "peer_id" ;
        dcterms:description "ID of this peer" ;
        rdf:type jsonschema:IntegerSchema ;
        jsonschema:format "uint64" ;
        jsonschema:minimum 0 ;
        ] , 
        [ 
        jsonschema:propertyName "peers" ;
        dcterms:description "Peers composition of the cluster with main information" ;
        rdf:type jsonschema:ObjectSchema ;
        jsonschema:properties qdrant:PeerInfo ;
        ] , 
        [ 
        jsonschema:propertyName "raft_info" ;
        rdf:type qdrant:RaftInfo ;
        ] , 
        [ 
        jsonschema:propertyName "consensus_thread_status" ;
        rdf:type qdrant:ConsensusThreadStatus ;
        ] , 
        [ 
        jsonschema:propertyName "message_send_failures" ;
        dcterms:description "Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap." ;
        rdf:type jsonschema:ObjectSchema ;
        jsonschema:properties qdrant:MessageSendErrors ;
        ] ;
      ] 
    ) .

# ClusterStatusTelemetry
# {"type" "object", "required" ["commit" "consensus_thread_status" "is_voter" "number_of_peers" "pending_operations" "term"], "properties" {"number_of_peers" {"type" "integer", "format" "uint", "minimum" 0}, "term" {"type" "integer", "format" "uint64", "minimum" 0}, "commit" {"type" "integer", "format" "uint64", "minimum" 0}, "pending_operations" {"type" "integer", "format" "uint", "minimum" 0}, "role" {"anyOf" [{"$ref" "#/components/schemas/StateRole"} {"nullable" true}]}, "is_voter" {"type" "boolean"}, "peer_id" {"type" "integer", "format" "uint64", "minimum" 0, "nullable" true}, "consensus_thread_status" {"$ref" "#/components/schemas/ConsensusThreadStatus"}}}

qdrant:ClusterStatusTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "commit" "consensus_thread_status" "is_voter" "number_of_peers" "pending_operations" "term" ) ;
  jsonschema:properties [
    jsonschema:propertyName "number_of_peers" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "term" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "commit" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "pending_operations" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "role" ;
    rdf:type qdrant:StateRole ;
    ], 
    [ 
    jsonschema:propertyName "is_voter" ;
    rdf:type jsonschema:BooleanSchema ;
    ], 
    [ 
    jsonschema:propertyName "peer_id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "consensus_thread_status" ;
    rdf:type qdrant:ConsensusThreadStatus ;
    ] .

# ClusterTelemetry
# {"type" "object", "required" ["enabled"], "properties" {"enabled" {"type" "boolean"}, "status" {"anyOf" [{"$ref" "#/components/schemas/ClusterStatusTelemetry"} {"nullable" true}]}, "config" {"anyOf" [{"$ref" "#/components/schemas/ClusterConfigTelemetry"} {"nullable" true}]}}}

qdrant:ClusterTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "enabled" ) ;
  jsonschema:properties [
    jsonschema:propertyName "enabled" ;
    rdf:type jsonschema:BooleanSchema ;
    ], 
    [ 
    jsonschema:propertyName "status" ;
    rdf:type qdrant:ClusterStatusTelemetry ;
    ], 
    [ 
    jsonschema:propertyName "config" ;
    rdf:type qdrant:ClusterConfigTelemetry ;
    ] .

# CollectionClusterInfo
# {"description" "Current clustering distribution for the collection", "type" "object", "required" ["local_shards" "peer_id" "remote_shards" "shard_count" "shard_transfers"], "properties" {"peer_id" {"description" "ID of this peer", "type" "integer", "format" "uint64", "minimum" 0}, "shard_count" {"description" "Total number of shards", "type" "integer", "format" "uint", "minimum" 0}, "local_shards" {"description" "Local shards", "type" "array", "items" {"$ref" "#/components/schemas/LocalShardInfo"}}, "remote_shards" {"description" "Remote shards", "type" "array", "items" {"$ref" "#/components/schemas/RemoteShardInfo"}}, "shard_transfers" {"description" "Shard transfers", "type" "array", "items" {"$ref" "#/components/schemas/ShardTransferInfo"}}}}

qdrant:CollectionClusterInfo a jsonschema:ObjectSchema ;
  dcterms:description "Current clustering distribution for the collection" ;
  jsonschema:required ( "local_shards" "peer_id" "remote_shards" "shard_count" "shard_transfers" ) ;
  jsonschema:properties [
    jsonschema:propertyName "peer_id" ;
    dcterms:description "ID of this peer" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "shard_count" ;
    dcterms:description "Total number of shards" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "local_shards" ;
    dcterms:description "Local shards" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:LocalShardInfo ;
    ], 
    [ 
    jsonschema:propertyName "remote_shards" ;
    dcterms:description "Remote shards" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:RemoteShardInfo ;
    ], 
    [ 
    jsonschema:propertyName "shard_transfers" ;
    dcterms:description "Shard transfers" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ShardTransferInfo ;
    ] .

# CollectionConfig
# {"type" "object", "required" ["hnsw_config" "optimizer_config" "params" "wal_config"], "properties" {"params" {"$ref" "#/components/schemas/CollectionParams"}, "hnsw_config" {"$ref" "#/components/schemas/HnswConfig"}, "optimizer_config" {"$ref" "#/components/schemas/OptimizersConfig"}, "wal_config" {"$ref" "#/components/schemas/WalConfig"}, "quantization_config" {"default" nil, "anyOf" [{"$ref" "#/components/schemas/QuantizationConfig"} {"nullable" true}]}}}

qdrant:CollectionConfig a jsonschema:ObjectSchema ;
  jsonschema:required ( "hnsw_config" "optimizer_config" "params" "wal_config" ) ;
  jsonschema:properties [
    jsonschema:propertyName "params" ;
    rdf:type qdrant:CollectionParams ;
    ], 
    [ 
    jsonschema:propertyName "hnsw_config" ;
    rdf:type qdrant:HnswConfig ;
    ], 
    [ 
    jsonschema:propertyName "optimizer_config" ;
    rdf:type qdrant:OptimizersConfig ;
    ], 
    [ 
    jsonschema:propertyName "wal_config" ;
    rdf:type qdrant:WalConfig ;
    ], 
    [ 
    jsonschema:propertyName "quantization_config" ;
    rdf:type qdrant:QuantizationConfig ;
    ] .

# CollectionDescription
# {"type" "object", "required" ["name"], "properties" {"name" {"type" "string"}}}

qdrant:CollectionDescription a jsonschema:ObjectSchema ;
  jsonschema:required ( "name" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "name" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# CollectionInfo
# {"description" "Current statistics and configuration of the collection", "type" "object", "required" ["config" "indexed_vectors_count" "optimizer_status" "payload_schema" "points_count" "segments_count" "status" "vectors_count"], "properties" {"status" {"$ref" "#/components/schemas/CollectionStatus"}, "optimizer_status" {"$ref" "#/components/schemas/OptimizersStatus"}, "vectors_count" {"description" "Number of vectors in collection All vectors in collection are available for querying Calculated as `points_count x vectors_per_point` Where `vectors_per_point` is a number of named vectors in schema", "type" "integer", "format" "uint", "minimum" 0}, "indexed_vectors_count" {"description" "Number of indexed vectors in the collection. Indexed vectors in large segments are faster to query, as it is stored in vector index (HNSW)", "type" "integer", "format" "uint", "minimum" 0}, "points_count" {"description" "Number of points (vectors + payloads) in collection Each point could be accessed by unique id", "type" "integer", "format" "uint", "minimum" 0}, "segments_count" {"description" "Number of segments in collection. Each segment has independent vector as payload indexes", "type" "integer", "format" "uint", "minimum" 0}, "config" {"$ref" "#/components/schemas/CollectionConfig"}, "payload_schema" {"description" "Types of stored payload", "type" "object", "additionalProperties" {"$ref" "#/components/schemas/PayloadIndexInfo"}}}}

qdrant:CollectionInfo a jsonschema:ObjectSchema ;
  dcterms:description "Current statistics and configuration of the collection" ;
  jsonschema:required ( "config" "indexed_vectors_count" "optimizer_status" "payload_schema" "points_count" "segments_count" "status" "vectors_count" ) ;
  jsonschema:properties [
    jsonschema:propertyName "status" ;
    rdf:type qdrant:CollectionStatus ;
    ], 
    [ 
    jsonschema:propertyName "optimizer_status" ;
    rdf:type qdrant:OptimizersStatus ;
    ], 
    [ 
    jsonschema:propertyName "vectors_count" ;
    dcterms:description "Number of vectors in collection All vectors in collection are available for querying Calculated as `points_count x vectors_per_point` Where `vectors_per_point` is a number of named vectors in schema" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "indexed_vectors_count" ;
    dcterms:description "Number of indexed vectors in the collection. Indexed vectors in large segments are faster to query, as it is stored in vector index (HNSW)" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "points_count" ;
    dcterms:description "Number of points (vectors + payloads) in collection Each point could be accessed by unique id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "segments_count" ;
    dcterms:description "Number of segments in collection. Each segment has independent vector as payload indexes" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "config" ;
    rdf:type qdrant:CollectionConfig ;
    ], 
    [ 
    jsonschema:propertyName "payload_schema" ;
    dcterms:description "Types of stored payload" ;
    rdf:type qdrant:PayloadIndexInfo ;
    ] .

# CollectionParams
# {"type" "object", "required" ["vectors"], "properties" {"vectors" {"$ref" "#/components/schemas/VectorsConfig"}, "shard_number" {"description" "Number of shards the collection has", "default" 1, "type" "integer", "format" "uint32", "minimum" 1}, "replication_factor" {"description" "Number of replicas for each shard", "default" 1, "type" "integer", "format" "uint32", "minimum" 1}, "write_consistency_factor" {"description" "Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.", "default" 1, "type" "integer", "format" "uint32", "minimum" 1}, "on_disk_payload" {"description" "If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.", "default" false, "type" "boolean"}}}

qdrant:CollectionParams a jsonschema:ObjectSchema ;
  jsonschema:required ( "vectors" ) ;
  jsonschema:properties [
    jsonschema:propertyName "vectors" ;
    rdf:type qdrant:VectorsConfig ;
    ], 
    [ 
    jsonschema:propertyName "shard_number" ;
    dcterms:description "Number of shards the collection has" ;
    jsonschema:default 1 ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 1 ;
    ], 
    [ 
    jsonschema:propertyName "replication_factor" ;
    dcterms:description "Number of replicas for each shard" ;
    jsonschema:default 1 ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 1 ;
    ], 
    [ 
    jsonschema:propertyName "write_consistency_factor" ;
    dcterms:description "Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact." ;
    jsonschema:default 1 ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 1 ;
    ], 
    [ 
    jsonschema:propertyName "on_disk_payload" ;
    dcterms:description "If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM." ;
    jsonschema:default "false"^^xsd:boolean ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# CollectionParamsDiff
# {"type" "object", "properties" {"replication_factor" {"description" "Number of replicas for each shard", "type" "integer", "format" "uint32", "minimum" 1, "nullable" true}, "write_consistency_factor" {"description" "Minimal number successful responses from replicas to consider operation successful", "type" "integer", "format" "uint32", "minimum" 1, "nullable" true}}}

qdrant:CollectionParamsDiff a jsonschema:ObjectSchema ;
  jsonschema:properties [
    jsonschema:propertyName "replication_factor" ;
    dcterms:description "Number of replicas for each shard" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 1 ;
    ], 
    [ 
    jsonschema:propertyName "write_consistency_factor" ;
    dcterms:description "Minimal number successful responses from replicas to consider operation successful" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 1 ;
    ] .

# CollectionStatus
# {"description" "Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered", "type" "string", "enum" ["green" "yellow" "red"]}

qdrant:CollectionStatus a jsonschema:StringSchema ;
  jsonschema:enum ( "green" "yellow" "red" ) ;
  dcterms:description "Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered" .

# CollectionTelemetry
# {"type" "object", "required" ["config" "id" "init_time_ms" "shards" "transfers"], "properties" {"id" {"type" "string"}, "init_time_ms" {"type" "integer", "format" "uint64", "minimum" 0}, "config" {"$ref" "#/components/schemas/CollectionConfig"}, "shards" {"type" "array", "items" {"$ref" "#/components/schemas/ReplicaSetTelemetry"}}, "transfers" {"type" "array", "items" {"$ref" "#/components/schemas/ShardTransferInfo"}}}}

qdrant:CollectionTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "config" "id" "init_time_ms" "shards" "transfers" ) ;
  jsonschema:properties [
    jsonschema:propertyName "id" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    jsonschema:propertyName "init_time_ms" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "config" ;
    rdf:type qdrant:CollectionConfig ;
    ], 
    [ 
    jsonschema:propertyName "shards" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ReplicaSetTelemetry ;
    ], 
    [ 
    jsonschema:propertyName "transfers" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ShardTransferInfo ;
    ] .

# CollectionTelemetryEnum
# {"anyOf" [{"$ref" "#/components/schemas/CollectionTelemetry"} {"$ref" "#/components/schemas/CollectionsAggregatedTelemetry"}]}

qdrant:CollectionTelemetryEnum a jsonschema:DataSchema ;
  jsonschema:anyOf ( qdrant:CollectionTelemetry qdrant:CollectionsAggregatedTelemetry ) .

# CollectionsAggregatedTelemetry
# {"type" "object", "required" ["optimizers_status" "params" "vectors"], "properties" {"vectors" {"type" "integer", "format" "uint", "minimum" 0}, "optimizers_status" {"$ref" "#/components/schemas/OptimizersStatus"}, "params" {"$ref" "#/components/schemas/CollectionParams"}}}

qdrant:CollectionsAggregatedTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "optimizers_status" "params" "vectors" ) ;
  jsonschema:properties [
    jsonschema:propertyName "vectors" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "optimizers_status" ;
    rdf:type qdrant:OptimizersStatus ;
    ], 
    [ 
    jsonschema:propertyName "params" ;
    rdf:type qdrant:CollectionParams ;
    ] .

# CollectionsAliasesResponse
# {"type" "object", "required" ["aliases"], "properties" {"aliases" {"type" "array", "items" {"$ref" "#/components/schemas/AliasDescription"}}}}

qdrant:CollectionsAliasesResponse a jsonschema:ObjectSchema ;
  jsonschema:required ( "aliases" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "aliases" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:AliasDescription ;
    ]) .

# CollectionsResponse
# {"type" "object", "required" ["collections"], "properties" {"collections" {"type" "array", "items" {"$ref" "#/components/schemas/CollectionDescription"}}}}

qdrant:CollectionsResponse a jsonschema:ObjectSchema ;
  jsonschema:required ( "collections" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "collections" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:CollectionDescription ;
    ]) .

# CollectionsTelemetry
# {"type" "object", "required" ["number_of_collections"], "properties" {"number_of_collections" {"type" "integer", "format" "uint", "minimum" 0}, "collections" {"type" "array", "items" {"$ref" "#/components/schemas/CollectionTelemetryEnum"}, "nullable" true}}}

qdrant:CollectionsTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "number_of_collections" ) ;
  jsonschema:properties [
    jsonschema:propertyName "number_of_collections" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "collections" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:CollectionTelemetryEnum ;
    ] .

# CompressionRatio
# {"type" "string", "enum" ["x4" "x8" "x16" "x32" "x64"]}

qdrant:CompressionRatio a jsonschema:StringSchema ;
  jsonschema:enum ( "x4" "x8" "x16" "x32" "x64" ) .

# Condition
# {"anyOf" [{"$ref" "#/components/schemas/FieldCondition"} {"$ref" "#/components/schemas/IsEmptyCondition"} {"$ref" "#/components/schemas/IsNullCondition"} {"$ref" "#/components/schemas/HasIdCondition"} {"$ref" "#/components/schemas/NestedCondition"} {"$ref" "#/components/schemas/Filter"}]}

qdrant:Condition a jsonschema:DataSchema ;
  jsonschema:oneOf ( qdrant:FieldCondition qdrant:IsEmptyCondition qdrant:IsNullCondition qdrant:HasIdCondition qdrant:NestedCondition qdrant:Filter ) .

# ConsensusConfigTelemetry
# {"type" "object", "required" ["bootstrap_timeout_sec" "max_message_queue_size" "tick_period_ms"], "properties" {"max_message_queue_size" {"type" "integer", "format" "uint", "minimum" 0}, "tick_period_ms" {"type" "integer", "format" "uint64", "minimum" 0}, "bootstrap_timeout_sec" {"type" "integer", "format" "uint64", "minimum" 0}}}

qdrant:ConsensusConfigTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "bootstrap_timeout_sec" "max_message_queue_size" "tick_period_ms" ) ;
  jsonschema:properties [
    jsonschema:propertyName "max_message_queue_size" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "tick_period_ms" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "bootstrap_timeout_sec" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ] .

# ConsensusThreadStatus
# {"description" "Information about current consensus thread status", "oneOf" [{"type" "object", "required" ["consensus_thread_status" "last_update"], "properties" {"consensus_thread_status" {"type" "string", "enum" ["working"]}, "last_update" {"type" "string", "format" "date-time"}}} {"type" "object", "required" ["consensus_thread_status"], "properties" {"consensus_thread_status" {"type" "string", "enum" ["stopped"]}}} {"type" "object", "required" ["consensus_thread_status" "err"], "properties" {"consensus_thread_status" {"type" "string", "enum" ["stopped_with_err"]}, "err" {"type" "string"}}}]}


qdrant:ConsensusThreadStatus a jsonschema:DataSchema ;
  dcterms:description "Information about current consensus thread status" ;
  jsonschema:oneOf ( [ 
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:required ( "consensus_thread_status" "last_update" ) ;
      jsonschema:properties [
        jsonschema:propertyName "consensus_thread_status" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:enum ( "working" ) ;
        ], 
        [ 
        jsonschema:propertyName "last_update" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:format "date-time" ;
        ] 
      ] 
    [ 
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:required ( "consensus_thread_status" ) ;
      jsonschema:properties [
        jsonschema:propertyName "consensus_thread_status" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:enum ( "stopped" ) ;
        ] 
      ]
    [ 
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:required ( "consensus_thread_status" "err" ) ;
      jsonschema:properties [
        jsonschema:propertyName "consensus_thread_status" ;
        rdf:type jsonschema:StringSchema ;
        jsonschema:enum ( "stopped_with_err" ) ;
        ], 
        [ 
        jsonschema:propertyName "err" ;
        rdf:type jsonschema:StringSchema ;
        ] ] ) .

# CountRequest
# {"description" "Count Request Counts the number of points which satisfy the given filter. If filter is not provided, the count of all points in the collection will be returned.", "type" "object", "properties" {"filter" {"description" "Look only for points which satisfies this conditions", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "exact" {"description" "If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true", "default" true, "type" "boolean"}}}

qdrant:CountRequest a jsonschema:ObjectSchema ;
  dcterms:description "Count Request Counts the number of points which satisfy the given filter. If filter is not provided, the count of all points in the collection will be returned." ;
  jsonschema:properties [
    jsonschema:propertyName "filter" ;
    dcterms:description "Look only for points which satisfies this conditions" ;
    jsonschema:anyOf ( qdrant:Filter jsonschema:NullSchema ) ;
    ], 
    [ 
    jsonschema:propertyName "exact" ;
    dcterms:description "If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true" ;
    jsonschema:default true ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# CountResult
# {"type" "object", "required" ["count"], "properties" {"count" {"description" "Number of points which satisfy the conditions", "type" "integer", "format" "uint", "minimum" 0}}}

qdrant:CountResult a jsonschema:ObjectSchema ;
  jsonschema:required ( "count" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "count" ;
    dcterms:description "Number of points which satisfy the conditions" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ]) .

# CreateAlias
# {"description" "Create alternative name for a collection. Collection will be available under both names for search, retrieve,", "type" "object", "required" ["alias_name" "collection_name"], "properties" {"collection_name" {"type" "string"}, "alias_name" {"type" "string"}}}

qdrant:CreateAlias a jsonschema:ObjectSchema ;
  dcterms:description "Create alternative name for a collection. Collection will be available under both names for search, retrieve," ;
  jsonschema:required ( "alias_name" "collection_name" ) ;
  jsonschema:properties [
    jsonschema:propertyName "collection_name" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    jsonschema:propertyName "alias_name" ;
    rdf:type jsonschema:StringSchema ;
    ] .

# CreateAliasOperation
# {"type" "object", "required" ["create_alias"], "properties" {"create_alias" {"$ref" "#/components/schemas/CreateAlias"}}}

qdrant:CreateAliasOperation a jsonschema:ObjectSchema ;
  jsonschema:required ( "create_alias" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "create_alias" ;
    rdf:type qdrant:CreateAlias ;
    ]) .

# CreateCollection
# {"description" "Operation for creating new collection and (optionally) specifyn index params", "type" "object", "required" ["vectors"], "properties" {"vectors" {"$ref" "#/components/schemas/VectorsConfig"}, "wal_config" {"description" "Custom params for WAL. If none - values from service configuration file are used.", "anyOf" [{"$ref" "#/components/schemas/WalConfigDiff"} {"nullable" true}]}, "init_from" {"description" "Specify other collection to copy data from.", "default" nil, "anyOf" [{"$ref" "#/components/schemas/InitFrom"} {"nullable" true}]}, "quantization_config" {"description" "Quantization parameters. If none - quantization is disabled.", "default" nil, "anyOf" [{"$ref" "#/components/schemas/QuantizationConfig"} {"nullable" true}]}, "replication_factor" {"description" "Number of shards replicas. Default is 1 Minimum is 1", "default" nil, "type" "integer", "format" "uint32", "minimum" 0, "nullable" true}, "optimizers_config" {"description" "Custom params for Optimizers.  If none - values from service configuration file are used.", "anyOf" [{"$ref" "#/components/schemas/OptimizersConfigDiff"} {"nullable" true}]}, "write_consistency_factor" {"description" "Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.", "default" nil, "type" "integer", "format" "uint32", "minimum" 0, "nullable" true}, "shard_number" {"description" "Number of shards in collection. Default is 1 for standalone, otherwise equal to the number of nodes Minimum is 1", "default" nil, "type" "integer", "format" "uint32", "minimum" 0, "nullable" true}, "hnsw_config" {"description" "Custom params for HNSW index. If none - values from service configuration file are used.", "anyOf" [{"$ref" "#/components/schemas/HnswConfigDiff"} {"nullable" true}]}, "on_disk_payload" {"description" "If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.", "default" nil, "type" "boolean", "nullable" true}}}

qdrant:CreateCollection a jsonschema:ObjectSchema ;
  dcterms:description "Operation for creating new collection and (optionally) specify index params" ;
  jsonschema:required ( "vectors" ) ;
  jsonschema:properties [
    jsonschema:propertyName "vectors" ;
    rdf:type qdrant:VectorsConfig ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "wal_config" ;
    dcterms:description "Custom params for WAL. If none - values from service configuration file are used." ;
    jsonschema:anyOf ( qdrant:WalConfigDiff jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "init_from" ;
    dcterms:description "Specify other collection to copy data from." ;
    jsonschema:anyOf ( qdrant:InitFrom jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "quantization_config" ;
    dcterms:description "Quantization parameters. If none - quantization is disabled." ;
    jsonschema:anyOf ( qdrant:QuantizationConfig jsonschema:NullSchema ) ;
    ], 
    [ 
    jsonschema:propertyName "replication_factor" ;
    dcterms:description "Number of shards replicas. Default is 1 Minimum is 1" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "optimizers_config" ;
    dcterms:description "Custom params for Optimizers.  If none - values from service configuration file are used." ;
    jsonschema:anyOf ( qdrant:OptimizersConfigDiff jsonschema:NullSchema ) ;
    ], 
    [ 
    jsonschema:propertyName "write_consistency_factor" ;
    dcterms:description "Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact." ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 0 ;
    ],
    [
    jsonschema:propertyName "shard_number" ;
    dcterms:description "Number of shards in collection. Default is 1 for standalone, otherwise equal to the number of nodes Minimum is 1" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 0 ;
    ],
    [
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "hnsw_config" ;
    dcterms:description "Custom params for HNSW index. If none - values from service configuration file are used." ;
    jsonschema:anyOf ( qdrant:HnswConfigDiff jsonschema:NullSchema ) ;
    ],
    [
    jsonschema:propertyName "on_disk_payload" ;
    dcterms:description "If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM." ;
    rdf:type jsonschema:BooleanSchema ;
    ] .
    
# CreateFieldIndex
# {"type" "object", "required" ["field_name"], "properties" {"field_name" {"type" "string"}, "field_schema" {"anyOf" [{"$ref" "#/components/schemas/PayloadFieldSchema"} {"nullable" true}]}}}

qdrant:CreateFieldIndex a jsonschema:ObjectSchema ;
  dcterms:description "Operation for creating new field index" ;
  jsonschema:required ( "field_name" ) ;
  jsonschema:properties [
    jsonschema:propertyName "field_name" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "field_schema" ;
    dcterms:description "Field schema. If none - default schema is used." ;
    jsonschema:anyOf ( qdrant:PayloadFieldSchema jsonschema:NullSchema ) ;
    ] .

# DeleteAlias
# {"description" "Delete alias if exists", "type" "object", "required" ["alias_name"], "properties" {"alias_name" {"type" "string"}}}

qdrant:DeleteAlias a jsonschema:ObjectSchema ;
  dcterms:description "Delete alias if exists" ;
  jsonschema:required ( "alias_name" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "alias_name" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# DeleteAliasOperation
# {"description" "Delete alias if exists", "type" "object", "required" ["delete_alias"], "properties" {"delete_alias" {"$ref" "#/components/schemas/DeleteAlias"}}}

qdrant:DeleteAliasOperation a jsonschema:ObjectSchema ;
  dcterms:description "Delete alias if exists" ;
  jsonschema:required ( "delete_alias" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "delete_alias" ;
    rdf:type qdrant:DeleteAlias ;
    ]) .

# DeletePayload
# {"type" "object", "required" ["keys"], "properties" {"keys" {"description" "List of payload keys to remove from payload", "type" "array", "items" {"type" "string"}}, "points" {"description" "Deletes values from each point in this list", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}, "nullable" true}, "filter" {"description" "Deletes values from points that satisfy this filter condition", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}}}

qdrant:DeletePayload a jsonschema:ObjectSchema ;
  dcterms:description "Deletes payload values from points" ;
  jsonschema:required ( "keys" ) ;
  jsonschema:properties [
    jsonschema:propertyName "keys" ;
    dcterms:description "List of payload keys to remove from payload" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items jsonschema:StringSchema ;
    ],
    [ 
    jsonschema:propertyName "points" ;
    dcterms:description "Deletes values from each point in this list" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "filter" ;
    dcterms:description "Deletes values from points that satisfy this filter condition" ;
    jsonschema:anyOf ( qdrant:Filter jsonschema:NullSchema ) ;
    ] .

# DeleteVectors
# {"type" "object", "required" ["vector"], "properties" {"points" {"description" "Deletes values from each point in this list", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}, "nullable" true}, "filter" {"description" "Deletes values from points that satisfy this filter condition", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "vector" {"description" "Vector names", "type" "array", "items" {"type" "string"}, "minItems" 1, "uniqueItems" true}}}

qdrant:DeleteVectors a jsonschema:ObjectSchema ;
  dcterms:description "Deletes vectors from points" ;
  jsonschema:required ( "vector" ) ;
  jsonschema:properties [
    jsonschema:propertyName "points" ;
    dcterms:description "Deletes values from each point in this list" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "filter" ;
    dcterms:description "Deletes values from points that satisfy this filter condition" ;
    jsonschema:anyOf ( qdrant:Filter jsonschema:NullSchema ) ;
    ], 
    [ 
    jsonschema:propertyName "vector" ;
    dcterms:description "Vector names" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items jsonschema:StringSchema ;
    jsonschema:minItems 1 ;
    jsonschema:uniqueItems true ;
    ] .

# Distance
# {"description" "Type of internal tags, build from payload Distance function types used to compare vectors", "type" "string", "enum" ["Cosine" "Euclid" "Dot"]}

qdrant:Distance a jsonschema:StringSchema ;
  dcterms:description "Type of internal tags, build from payload Distance function types used to compare vectors" ;
  jsonschema:enum ( "Cosine" "Euclid" "Dot" ) .

# DropReplicaOperation
# {"type" "object", "required" ["drop_replica"], "properties" {"drop_replica" {"$ref" "#/components/schemas/Replica"}}}

qdrant:DropReplicaOperation a jsonschema:ObjectSchema ;
  dcterms:description "Drop replica operation" ;
  jsonschema:required ( "drop_replica" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "drop_replica" ;
    rdf:type qdrant:Replica ;
    ]) .

# ErrorResponse
# {"type" "object", "properties" {"time" {"type" "number", "format" "float", "description" "Time spent to process this request"}, "status" {"type" "object", "properties" {"error" {"type" "string", "description" "Description of the occurred error."}}}, "result" {"type" "object", "nullable" true}}}

qdrant:ErrorResponse a jsonschema:ObjectSchema ;
  dcterms:description "Error response" ;
  jsonschema:properties [
    jsonschema:propertyName "time" ;
    dcterms:description "Time spent to process this request" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    ],
    [ 
    jsonschema:propertyName "status" ;
    rdf:type jsonschema:ObjectSchema ;
    jsonschema:properties [
      jsonschema:propertyName "error" ;
      dcterms:description "Description of the occurred error." ;
      rdf:type jsonschema:StringSchema ;
      ] ;
    ], 
    [ 
    jsonschema:propertyName "result" ;
    rdf:type jsonschema:ObjectSchema ;
    ] .

qdrant:SuccessfulResponse a jsonschema:ObjectSchema ;
  dcterms:description "Successful operation" ;
  jsonschema:properties [
    jsonschema:propertyName "time" ;
    dcterms:description "Time spent to process this request" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    ],
    [ 
    jsonschema:propertyName "status" ;
    rdf:type jsonschema:StringSchema ;
    jsonschema:enum ( "ok" ) ;
    ], 
    [ 
    jsonschema:propertyName "result" ;
    rdf:type jsonschema:ObjectSchema ;
    ] .

# ExtendedPointId
# {"description" "Type, used for specifying point ID in user interface", "anyOf" [{"type" "integer", "format" "uint64", "minimum" 0} {"type" "string", "format" "uuid"}]}

qdrant:ExtendedPointId a jsonschema:DataSchema ;
  dcterms:description "Type, used for specifying point ID in user interface" ;
  jsonschema:anyOf (
    [
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:minimum 0 ;
      jsonschema:format "uint64" ;
      ] 
    [
      rdf:type jsonschema:StringSchema ;
      jsonschema:format "uuid" ;
      ] 
    ) .

# FieldCondition
# {"description" "All possible payload filtering conditions", "type" "object", "required" ["key"], "properties" {"key" {"description" "Payload key", "type" "string"}, "match" {"description" "Check if point has field with a given value", "anyOf" [{"$ref" "#/components/schemas/Match"} {"nullable" true}]}, "range" {"description" "Check if points value lies in a given range", "anyOf" [{"$ref" "#/components/schemas/Range"} {"nullable" true}]}, "geo_bounding_box" {"description" "Check if points geo location lies in a given area", "anyOf" [{"$ref" "#/components/schemas/GeoBoundingBox"} {"nullable" true}]}, "geo_radius" {"description" "Check if geo point is within a given radius", "anyOf" [{"$ref" "#/components/schemas/GeoRadius"} {"nullable" true}]}, "values_count" {"description" "Check number of values of the field", "anyOf" [{"$ref" "#/components/schemas/ValuesCount"} {"nullable" true}]}}}

qdrant:FieldCondition a jsonschema:ObjectSchema ;
  dcterms:description "All possible payload filtering conditions" ;
  jsonschema:required ( "key" ) ;
  jsonschema:properties [
    jsonschema:propertyName "key" ;
    dcterms:description "Payload key" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "match" ;
    dcterms:description "Check if point has field with a given value" ;
    jsonschema:anyOf ( qdrant:Match jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "range" ;
    dcterms:description "Check if points value lies in a given range" ;
    jsonschema:anyOf ( qdrant:Range jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "geo_bounding_box" ;
    dcterms:description "Check if points geo location lies in a given area" ;
    jsonschema:anyOf ( qdrant:GeoBoundingBox jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "geo_radius" ;
    dcterms:description "Check if geo point is within a given radius" ;
    jsonschema:anyOf ( qdrant:GeoRadius jsonschema:NullSchema ) ;
    ], 
    [ 
    rdf:type jsonschema:DataSchema ;
    jsonschema:propertyName "values_count" ;
    dcterms:description "Check number of values of the field" ;
    jsonschema:anyOf ( qdrant:ValuesCount jsonschema:NullSchema ) ;
    ] .

# Filter
# {"type" "object", "properties" {"should" {"description" "At least one of those conditions should match", "type" "array", "items" {"$ref" "#/components/schemas/Condition"}, "nullable" true}, "must" {"description" "All conditions must match", "type" "array", "items" {"$ref" "#/components/schemas/Condition"}, "nullable" true}, "must_not" {"description" "All conditions must NOT match", "type" "array", "items" {"$ref" "#/components/schemas/Condition"}, "nullable" true}}, "additionalProperties" false}

qdrant:Filter a jsonschema:ObjectSchema ;
  jsonschema:properties [
    jsonschema:propertyName "should" ;
    dcterms:description "At least one of those conditions should match" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:Condition ;
    ], 
    [ 
    jsonschema:propertyName "must" ;
    dcterms:description "All conditions must match" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:Condition ;
    ], 
    [ 
    jsonschema:propertyName "must_not" ;
    dcterms:description "All conditions must NOT match" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:Condition ;
    ] .

# FilterSelector
# {"type" "object", "required" ["filter"], "properties" {"filter" {"$ref" "#/components/schemas/Filter"}}}

qdrant:FilterSelector a jsonschema:ObjectSchema ;
  jsonschema:required ( "filter" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "filter" ;
    rdf:type qdrant:Filter ;
    ]) .

# GeoBoundingBox
# {"description" "Geo filter request\n\nMatches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges", "type" "object", "required" ["bottom_right" "top_left"], "properties" {"top_left" {"$ref" "#/components/schemas/GeoPoint"}, "bottom_right" {"$ref" "#/components/schemas/GeoPoint"}}}

qdrant:GeoBoundingBox a jsonschema:ObjectSchema ;
  dcterms:description "Geo filter request\n\nMatches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges" ;
  jsonschema:required ( "bottom_right" "top_left" ) ;
  jsonschema:properties [
    jsonschema:propertyName "top_left" ;
    jsonschema:description "Geo point payload schema" ;
    rdf:type qdrant:GeoPoint ;
    ], 
    [ 
    jsonschema:propertyName "bottom_right" ;
    jsonschema:description "Geo point payload schema" ;
    rdf:type qdrant:GeoPoint ;
    ] .

# GeoPoint
# {"description" "Geo point payload schema", "type" "object", "required" ["lat" "lon"], "properties" {"lon" {"type" "number", "format" "double"}, "lat" {"type" "number", "format" "double"}}}

qdrant:GeoPoint a jsonschema:ObjectSchema ;
  dcterms:description "Geo point payload schema" ;
  jsonschema:required ( "lat" "lon" ) ;
  jsonschema:properties [
    jsonschema:propertyName "lon" ;
    rdf:type jsonschema:NumberSchema ;
    ], 
    [ 
    jsonschema:propertyName "lat" ;
    rdf:type jsonschema:NumberSchema ;
    ] .

# GeoRadius
# {"description" "Geo filter request\n\nMatches coordinates inside the circle of `radius` and center with coordinates `center`", "type" "object", "required" ["center" "radius"], "properties" {"center" {"$ref" "#/components/schemas/GeoPoint"}, "radius" {"description" "Radius of the area in meters", "type" "number", "format" "double"}}}

qdrant:GeoRadius a jsonschema:ObjectSchema ;
  dcterms:description "Geo filter request\n\nMatches coordinates inside the circle of `radius` and center with coordinates `center`" ;
  jsonschema:required ( "center" "radius" ) ;
  jsonschema:properties [
    jsonschema:propertyName "center" ;
    jsonschema:description "Geo point payload schema" ;
    rdf:type qdrant:GeoPoint ;
    ], 
    [ 
    jsonschema:propertyName "radius" ;
    jsonschema:description "Radius of the area in meters" ;
    rdf:type jsonschema:NumberSchema ;
    ] .

# GroupId
# {"anyOf" [{"type" "string"} {"type" "integer", "format" "uint64", "minimum" 0} {"type" "integer", "format" "int64"}]}

qdrant:GroupId a jsonschema:DataSchema ;
  jsonschema:anyOf [
    rdf:type jsonschema:StringSchema ;
    ],
    [
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ; 
    ],
    [
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "int64" ;
    ] .

# GroupsResult
# {"type" "object", "required" ["groups"], "properties" {"groups" {"type" "array", "items" {"$ref" "#/components/schemas/PointGroup"}}}}

qdrant:GroupsResult a jsonschema:ObjectSchema ;
  jsonschema:required ( "groups" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "groups" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:PointGroup ;
    ]) .

# GrpcTelemetry
# {"type" "object", "required" ["responses"], "properties" {"responses" {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/OperationDurationStatistics"}}}}

qdrant:GrpcTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ( "responses" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "responses" ;
    rdf:type jsonschema:ObjectSchema ;
    jsonschema:properties qdrant:OperationDurationStatistics ;
    ]) .

# HasIdCondition
# {"description" "ID-based filtering condition", "type" "object", "required" ["has_id"], "properties" {"has_id" {"type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}, "uniqueItems" true}}}

qdrant:HasIdCondition a jsonschema:ObjectSchema ;
  dcterms:description "ID-based filtering condition" ;
  jsonschema:required ( "has_id" ) ;
  jsonschema:properties ([
    jsonschema:propertyName "has_id" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    jsonschema:uniqueItems true ;
    ]) .

# HnswConfig
# {"description" "Config of HNSW index", "type" "object", "required" ["ef_construct" "full_scan_threshold" "m"], "properties" {"m" {"description" "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.", "type" "integer", "format" "uint", "minimum" 0}, "ef_construct" {"description" "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.", "type" "integer", "format" "uint", "minimum" 4}, "full_scan_threshold" {"description" "Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256", "type" "integer", "format" "uint", "minimum" 0}, "max_indexing_threads" {"description" "Number of parallel threads used for background index building. If 0 - auto selection.", "default" 0, "type" "integer", "format" "uint", "minimum" 0}, "on_disk" {"description" "Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false", "type" "boolean", "nullable" true}, "payload_m" {"description" "Custom M param for hnsw graph built for payload index. If not set, default M will be used.", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:HnswConfig a jsonschema:ObjectSchema ;
  dcterms:description "Config of HNSW index" ;
  jsonschema:required ( "ef_construct" "full_scan_threshold" "m" ) ;
  jsonschema:properties [
    jsonschema:propertyName "m" ;
    jsonschema:description "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required." ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "ef_construct" ;
    jsonschema:description "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index." ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 4 ;
    ], 
    [ 
    jsonschema:propertyName "full_scan_threshold" ;
    jsonschema:description "Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "max_indexing_threads" ;
    jsonschema:description "Number of parallel threads used for background index building. If 0 - auto selection." ;
    jsonschema:default 0 ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ], 
    [ 
    jsonschema:propertyName "on_disk" ;
    jsonschema:description "Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false" ;
    rdf:type jsonschema:BooleanSchema ;
    ], 
    [ 
    jsonschema:propertyName "payload_m" ;
    jsonschema:description "Custom M param for hnsw graph built for payload index . If not set, default M will be used." ; 
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] .

# HnswConfigDiff
# {"type" "object", "properties" {"m" {"description" "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "ef_construct" {"description" "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.", "type" "integer", "format" "uint", "minimum" 4, "nullable" true}, "full_scan_threshold" {"description" "Minimal size (in kilobytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256", "type" "integer", "format" "uint", "minimum" 1000, "nullable" true}, "max_indexing_threads" {"description" "Number of parallel threads used for background index building. If 0 - auto selection.", "type" "integer", "format" "uint", "minimum" 1000, "nullable" true}, "on_disk" {"description" "Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false", "type" "boolean", "nullable" true}, "payload_m" {"description" "Custom M param for additional payload-aware HNSW links. If not set, default M will be used.", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:HnswConfigDiff a jsonschema:ObjectSchema ;
  jsonschema:properties (
    [ 
      jsonschema:propertyName "m" ;
      dcterms:description "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required." ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "ef_construct" ;
      dcterms:description "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index." ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 4 ;
      ]
    [
      jsonschema:propertyName "full_scan_threshold" ;
      dcterms:description "Minimal size (in kilobytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 1000 ;
      ]
    [
      jsonschema:propertyName "max_indexing_threads" ;
      dcterms:description "Number of parallel threads used for background index building. If 0 - auto selection." ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 1000 ;
      ]
    [
      jsonschema:propertyName "on_disk" ;
      dcterms:description "Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "payload_m" ;
      dcterms:description "Custom M param for additional payload-aware HNSW links. If not set, default M will be used." ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# Indexes
# {"description" "Vector index configuration", "oneOf" [{"description" "Do not use any index, scan whole vector collection during search. Guarantee 100% precision, but may be time consuming on large collections.", "type" "object", "required" ["options" "type"], "properties" {"type" {"type" "string", "enum" ["plain"]}, "options" {"type" "object"}}} {"description" "Use filterable HNSW index for approximate search. Is very fast even on a very huge collections, but require additional space to store index and additional time to build it.", "type" "object", "required" ["options" "type"], "properties" {"type" {"type" "string", "enum" ["hnsw"]}, "options" {"$ref" "#/components/schemas/HnswConfig"}}}]}

qdrant:Indexes a jsonschema:ObjectSchema ;
  dcterms:description "Vector index configuration" ;
  jsonschema:oneOf (
    [ 
      rdf:type jsonschema:ObjectSchema ;
      dcterms:description "Do not use any index, scan the whole vector collection during search. Guarantee 100% precision, but may be time-consuming on large collections." ;
      jsonschema:required ("options" "type") ;
      jsonschema:properties (
        [ 
          jsonschema:propertyName "type" ;
          rdf:type jsonschema:StringSchema ;
          jsonschema:enum (
            "plain"
            )
          ]
        [
          jsonschema:propertyName "options" ;
          rdf:type jsonschema:ObjectSchema ;
          ]
        )
      ]
    [
      rdf:type jsonschema:ObjectSchema ;
      dcterms:description "Use filterable HNSW index for approximate search. Is very fast even on a very huge collections, but require additional space to store index and additional time to build it." ;
      jsonschema:required ("options" "type") ;
      jsonschema:properties (
        [ 
          jsonschema:propertyName "type" ;
          rdf:type jsonschema:StringSchema ;
          jsonschema:enum (
            "hnsw"
            )
          ]
        [
          jsonschema:propertyName "options" ;
          rdf:type jsonschema:ObjectSchema ;
          jsonschema:ref qdrant:HnswConfig ;
          ]
        )
      ]
    ) .

# InitFrom
# {"description" "Operation for creating new collection and (optionally) specify index params", "type" "object", "required" ["collection"], "properties" {"collection" {"type" "string"}}}

qdrant:InitFrom a jsonschema:ObjectSchema ;
  dcterms:description "Operation for creating new collection and (optionally) specify index params" ;
  jsonschema:required "collection" ;
  jsonschema:properties ([
    jsonschema:propertyName "collection" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# IsEmptyCondition
# {"description" "Select points with empty payload for a specified field", "type" "object", "required" ["is_empty"], "properties" {"is_empty" {"$ref" "#/components/schemas/PayloadField"}}}

qdrant:IsEmptyCondition a jsonschema:ObjectSchema ;
  dcterms:description "Select points with empty payload for a specified field" ;
  jsonschema:required "is_empty" ;
  jsonschema:properties ([
    jsonschema:propertyName "is_empty" ;
    rdf:type qdrant:PayloadField ;
    ]) .

# IsNullCondition
# {"description" "Select points with null payload for a specified field", "type" "object", "required" ["is_null"], "properties" {"is_null" {"$ref" "#/components/schemas/PayloadField"}}}

qdrant:IsNullCondition a jsonschema:ObjectSchema ;
  dcterms:description "Select points with null payload for a specified field" ;
  jsonschema:required "is_null" ;
  jsonschema:properties ([
    jsonschema:propertyName "is_null" ;
    rdf:type qdrant:PayloadField ;
    ]) .

# LocalShardInfo
# {"type" "object", "required" ["points_count" "shard_id" "state"], "properties" {"shard_id" {"description" "Local shard id", "type" "integer", "format" "uint32", "minimum" 0}, "points_count" {"description" "Number of points in the shard", "type" "integer", "format" "uint", "minimum" 0}, "state" {"$ref" "#/components/schemas/ReplicaState"}}}

qdrant:LocalShardInfo a jsonschema:ObjectSchema ;
  jsonschema:required ("points_count" "shard_id" "state") ;
  jsonschema:properties [
    jsonschema:propertyName "shard_id" ;
    dcterms:description "Local shard id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 0 ;
    ],
    [
    jsonschema:propertyName "points_count" ;
    dcterms:description "Number of points in the shard" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ],
    [
    jsonschema:propertyName "state" ;
    rdf:type qdrant:ReplicaState ;
    ] .

# LocalShardTelemetry
# {"type" "object", "required" ["optimizations" "segments"], "properties" {"variant_name" {"type" "string", "nullable" true}, "segments" {"type" "array", "items" {"$ref" "#/components/schemas/SegmentTelemetry"}}, "optimizations" {"$ref" "#/components/schemas/OptimizerTelemetry"}}}

qdrant:LocalShardTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ("optimizations" "segments") ;
  jsonschema:properties [
    jsonschema:propertyName "variant_name" ;
    rdf:type jsonschema:StringSchema ;
    ],
    [
    jsonschema:propertyName "segments" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:SegmentTelemetry ;
    ],
    [
    jsonschema:propertyName "optimizations" ;
    rdf:type qdrant:OptimizerTelemetry ;
    ] .

# LocksOption
# {"type" "object", "required" ["write"], "properties" {"error_message" {"type" "string", "nullable" true}, "write" {"type" "boolean"}}}

qdrant:LocksOption a jsonschema:ObjectSchema ;
  jsonschema:required ("write") ;
  jsonschema:properties [
    jsonschema:propertyName "error_message" ;
    rdf:type jsonschema:StringSchema ;
    ], 
    [
    jsonschema:propertyName "write" ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# LookupLocation
# {"description" "Defines a location to use for looking up the vector. Specifies collection and vector field name.", "type" "object", "required" ["collection"], "properties" {"collection" {"description" "Name of the collection used for lookup", "type" "string"}, "vector" {"description" "Optional name of the vector field within the collection. If not provided, the default vector field will be used.", "default" nil, "type" "string", "nullable" true}}}

qdrant:LookupLocation a jsonschema:ObjectSchema ;
  jsonschema:required ("collection") ;
  jsonschema:properties [
    jsonschema:propertyName "collection" ;
    rdf:type jsonschema:StringSchema ;
    dcterms:description "Name of the collection used for lookup" ;
    ], 
    [
    jsonschema:propertyName "vector" ;
    rdf:type jsonschema:StringSchema ;
    dcterms:description "Optional name of the vector field within the collection. If not provided, the default vector field will be used." ; 
    ] .

# Match
# {"description" "Match filter request", "anyOf" [{"$ref" "#/components/schemas/MatchValue"} {"$ref" "#/components/schemas/MatchText"} {"$ref" "#/components/schemas/MatchAny"} {"$ref" "#/components/schemas/MatchExcept"}]}

qdrant:Match a jsonschema:DataSchema ;
  dcterms:description "Match filter request" ;
  jsonschema:anyOf (qdrant:MatchValue qdrant:MatchText qdrant:MatchAny qdrant:MatchExcept) .

# MatchAny
# {"description" "Exact match on any of the given values", "type" "object", "required" ["any"], "properties" {"any" {"$ref" "#/components/schemas/AnyVariants"}}}

qdrant:MatchAny a jsonschema:ObjectSchema ;
  jsonschema:required ("any") ;
  jsonschema:properties ([
    jsonschema:propertyName "any" ;
    rdf:type qdrant:AnyVariants ;
    ]) .

# MatchExcept
# {"description" "Should have at least one value not matching the any given values", "type" "object", "required" ["except"], "properties" {"except" {"$ref" "#/components/schemas/AnyVariants"}}}

qdrant:MatchExcept a jsonschema:ObjectSchema ;
  jsonschema:required ("except") ;
  jsonschema:properties ([
    jsonschema:propertyName "except" ;
    rdf:type qdrant:AnyVariants ;
    ]) .

# MatchText
# {"description" "Full-text match of the strings.", "type" "object", "required" ["text"], "properties" {"text" {"type" "string"}}}

qdrant:MatchText a jsonschema:ObjectSchema ;
  jsonschema:required ("text") ;
  jsonschema:properties ([
    jsonschema:propertyName "text" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# MatchValue
# {"description" "Exact match of the given value", "type" "object", "required" ["value"], "properties" {"value" {"$ref" "#/components/schemas/ValueVariants"}}}

qdrant:MatchValue a jsonschema:ObjectSchema ;
  jsonschema:required ("value") ;
  jsonschema:properties ([
    jsonschema:propertyName "value" ;
    rdf:type qdrant:ValueVariants ;
    ]) .

# MessageSendErrors
# {"description" "Message send failures for a particular peer", "type" "object", "required" ["count"], "properties" {"count" {"type" "integer", "format" "uint", "minimum" 0}, "latest_error" {"type" "string", "nullable" true}}}

qdrant:MessageSendErrors a jsonschema:ObjectSchema ;
  jsonschema:required ("count") ;
  jsonschema:properties [
    jsonschema:propertyName "count" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "latest_error" ;
    rdf:type jsonschema:StringSchema ;
    ] .

# MoveShard
# {"type" "object", "required" ["from_peer_id" "shard_id" "to_peer_id"], "properties" {"shard_id" {"type" "integer", "format" "uint32", "minimum" 0}, "to_peer_id" {"type" "integer", "format" "uint64", "minimum" 0}, "from_peer_id" {"type" "integer", "format" "uint64", "minimum" 0}}}

qdrant:MoveShard a jsonschema:ObjectSchema ;
  jsonschema:required ("from_peer_id" "shard_id" "to_peer_id") ;
  jsonschema:properties [
    jsonschema:propertyName "shard_id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint32" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "to_peer_id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "from_peer_id" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ] .

# MoveShardOperation
# {"type" "object", "required" ["move_shard"], "properties" {"move_shard" {"$ref" "#/components/schemas/MoveShard"}}}

qdrant:MoveShardOperation a jsonschema:ObjectSchema ;
  jsonschema:required ("move_shard") ;
  jsonschema:properties ([
    jsonschema:propertyName "move_shard" ;
    rdf:type qdrant:MoveShard ;
    ]) .

# NamedVector
# {"description" "Vector data with name", "type" "object", "required" ["name" "vector"], "properties" {"name" {"description" "Name of vector data", "type" "string"}, "vector" {"description" "Vector data", "type" "array", "items" {"type" "number", "format" "float"}}}}

qdrant:NamedVector a jsonschema:ObjectSchema ;
  jsonschema:required ("name" "vector") ;
  jsonschema:properties [
    jsonschema:propertyName "name" ;
    jsonschema:type jsonschema:StringSchema ;
    ] ,
    [
    jsonschema:propertyName "vector" ;
    jsonschema:type jsonschema:ArraySchema ;
    jsonschema:items [
      jsonschema:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      ] ;
    ] .

# NamedVectorStruct
# {"description" "Vector data separator for named and unnamed modes Unanmed mode:\n\n{ \"vector\": [1.0, 2.0, 3.0] }\n\nor named mode:\n\n{ \"vector\": { \"vector\": [1.0, 2.0, 3.0], \"name\": \"image-embeddings\" } }", "anyOf" [{"type" "array", "items" {"type" "number", "format" "float"}} {"$ref" "#/components/schemas/NamedVector"}]}

qdrant:NamedVectorStruct a jsonschema:DataSchema ;
  jsonschema:anyOf ([
      jsonschema:type jsonschema:ArraySchema ;
      jsonschema:items [
        jsonschema:type jsonschema:NumberSchema ;
        jsonschema:format "float" ;
        ] ;
      ] 
    qdrant:NamedVector ) .

# Nested
# {"description" "Select points with payload for a specified nested field", "type" "object", "required" ["filter" "key"], "properties" {"key" {"type" "string"}, "filter" {"$ref" "#/components/schemas/Filter"}}}

qdrant:Nested a jsonschema:ObjectSchema ;
  jsonschema:required ("filter" "key") ;
  jsonschema:properties [
    jsonschema:propertyName "key" ;
    jsonschema:type jsonschema:StringSchema ;
    ] ,
    [
    jsonschema:propertyName "filter" ;
    jsonschema:type qdrant:Filter ;
    ] .

# NestedCondition
# {"type" "object", "required" ["nested"], "properties" {"nested" {"$ref" "#/components/schemas/Nested"}}}

qdrant:NestedCondition a jsonschema:ObjectSchema ;
  jsonschema:required ("nested") ;
  jsonschema:properties ([
    jsonschema:propertyName "nested" ;
    rdf:type qdrant:Nested ;
    ]) .

# OperationDurationStatistics
# {"type" "object", "required" ["count"], "properties" {"count" {"type" "integer", "format" "uint", "minimum" 0}, "fail_count" {"type" "integer", "format" "uint", "minimum" 0}, "avg_duration_micros" {"type" "number", "format" "float", "nullable" true}, "min_duration_micros" {"type" "number", "format" "float", "nullable" true}, "max_duration_micros" {"type" "number", "format" "float", "nullable" true}, "last_responded" {"type" "string", "format" "date-time", "nullable" true}}}

qdrant:OperationDurationStatistics a jsonschema:ObjectSchema ;
  jsonschema:required ("count") ;
  jsonschema:properties [
    jsonschema:propertyName "count" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "fail_count" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "avg_duration_micros" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    ] ,
    [
    jsonschema:propertyName "min_duration_micros" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    ] ,
    [
    jsonschema:propertyName "max_duration_micros" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    ] ,
    [
    jsonschema:propertyName "last_responded" ;
    rdf:type jsonschema:StringSchema ;
    jsonschema:format "date-time" ;
    ] .

# OptimizerTelemetry
# {"type" "object", "required" ["optimizations" "status"], "properties" {"status" {"$ref" "#/components/schemas/OptimizersStatus"}, "optimizations" {"$ref" "#/components/schemas/OperationDurationStatistics"}}}

qdrant:OptimizerTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ("optimizations" "status") ;
  jsonschema:properties [
    jsonschema:propertyName "status" ;
    rdf:type qdrant:OptimizersStatus ;
    ] ,
    [
    jsonschema:propertyName "optimizations" ;
    rdf:type qdrant:OperationDurationStatistics ;
    ] .

# OptimizersConfig
# {"type" "object", "required" ["default_segment_number" "deleted_threshold" "flush_interval_sec" "max_optimization_threads" "vacuum_min_vector_number"], "properties" {"deleted_threshold" {"description" "The minimal fraction of deleted vectors in a segment, required to perform segment optimization", "type" "number", "format" "double", "maximum" 1, "minimum" 0}, "vacuum_min_vector_number" {"description" "The minimal number of vectors in a segment, required to perform segment optimization", "type" "integer", "format" "uint", "minimum" 100}, "default_segment_number" {"description" "Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS\n\nIt is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads. If `default_segment_number = 0`, will be automatically selected by the number of available CPUs.", "type" "integer", "format" "uint", "minimum" 0}, "max_segment_size" {"description" "Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.\n\nIf indexing speed is more important - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256 If not set, will be automatically selected considering the number of available CPUs.", "default" nil, "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "memmap_threshold" {"description" "Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.\n\nMemmap storage is disabled by default, to enable it, set this threshold to a reasonable value.\n\nTo disable memmap storage, set this to `0`. Internally it will use the largest threshold possible.\n\nNote: 1Kb = 1 vector of size 256", "default" nil, "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "indexing_threshold" {"description" "Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing\n\nDefault value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.\n\nTo disable vector indexing, set to `0`.\n\nNote: 1kB = 1 vector of size 256.", "default" nil, "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "flush_interval_sec" {"description" "Minimum interval between forced flushes.", "type" "integer", "format" "uint64", "minimum" 0}, "max_optimization_threads" {"description" "Maximum available threads for optimization workers", "type" "integer", "format" "uint", "minimum" 0}}}

qdrant:OptimizersConfig a jsonschema:ObjectSchema ;
  jsonschema:required ("default_segment_number" "deleted_threshold" "flush_interval_sec" "max_optimization_threads" "vacuum_min_vector_number") ;
  jsonschema:properties [
    jsonschema:propertyName "deleted_threshold" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    jsonschema:minimum 0 ;
    jsonschema:maximum 1 ;
    ] ,
    [
    jsonschema:propertyName "vacuum_min_vector_number" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 100 ;
    ] ,
    [
    jsonschema:propertyName "default_segment_number" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "max_segment_size" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "memmap_threshold" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "indexing_threshold" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "flush_interval_sec" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "max_optimization_threads" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] .

# OptimizersConfigDiff
# {"type" "object", "properties" {"deleted_threshold" {"description" "The minimal fraction of deleted vectors in a segment, required to perform segment optimization", "type" "number", "format" "double", "nullable" true}, "vacuum_min_vector_number" {"description" "The minimal number of vectors in a segment, required to perform segment optimization", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "default_segment_number" {"description" "Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS\n\nIt is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "max_segment_size" {"description" "Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.\n\nIf indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "memmap_threshold" {"description" "Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.\n\nMemmap storage is disabled by default, to enable it, set this threshold to a reasonable value.\n\nTo disable memmap storage, set this to `0`.\n\nNote: 1Kb = 1 vector of size 256", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "indexing_threshold" {"description" "Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing\n\nDefault value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.\n\nTo disable vector indexing, set to `0`.\n\nNote: 1kB = 1 vector of size 256.", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "flush_interval_sec" {"description" "Minimum interval between forced flushes.", "type" "integer", "format" "uint64", "minimum" 0, "nullable" true}, "max_optimization_threads" {"description" "Maximum available threads for optimization workers", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:OptimizersConfigDiff a jsonschema:ObjectSchema ;
  jsonschema:required ("default_segment_number" "deleted_threshold" "flush_interval_sec" "max_optimization_threads" "vacuum_min_vector_number") ;
  jsonschema:properties [
    jsonschema:propertyName "deleted_threshold" ;
    rdf:type jsonschema:NumberSchema ;
    jsonschema:format "float" ;
    jsonschema:minimum 0 ;
    jsonschema:maximum 1 ;
    ] ,
    [
    jsonschema:propertyName "vacuum_min_vector_number" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 100 ;
    ] ,
    [
    jsonschema:propertyName "default_segment_number" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "max_segment_size" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "memmap_threshold" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "indexing_threshold" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "flush_interval_sec" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint64" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "max_optimization_threads" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] .

# OptimizersStatus
# {"description" "Current state of the collection", "oneOf" [{"description" "Optimizers are reporting as expected", "type" "string", "enum" ["ok"]} {"description" "Something wrong happened with optimizers", "type" "object", "required" ["error"], "properties" {"error" {"type" "string"}}, "additionalProperties" false}]}

qdrant:OptimizersStatus a jsonschema:ObjectSchema ;
  dcterms:description "Current state of the collection" ;
  jsonschema:oneOf
  [
    dcterms:description "Optimizers are reporting as expected" ;
    jsonschema:enum ("ok") ;
    rdf:type jsonschema:StringSchema ;
    ] ,
    [
    dcterms:description "Something wrong happened with optimizers" ;
    rdf:type jsonschema:ObjectSchema ;
    jsonschema:required ("error") ;
    jsonschema:properties [
      jsonschema:propertyName "error" ;
      rdf:type jsonschema:StringSchema ;
      ] ;
    ] .

# P2pConfigTelemetry
# {"type" "object", "required" ["connection_pool_size"], "properties" {"connection_pool_size" {"type" "integer", "format" "uint", "minimum" 0}}}

qdrant:P2pConfigTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ("connection_pool_size") ;
  jsonschema:properties ([
    jsonschema:propertyName "connection_pool_size" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ]) .

# Payload
# {"type" "object"}

qdrant:Payload a jsonschema:ObjectSchema .

# PayloadField
# {"description" "Payload field", "type" "object", "required" ["key"], "properties" {"key" {"description" "Payload field name", "type" "string"}}}

qdrant:PayloadField a jsonschema:ObjectSchema ;
  dcterms:description "Payload field" ;
  jsonschema:required ("key") ;
  jsonschema:properties ([
    jsonschema:propertyName "key" ;
    dcterms:description "Payload field name" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# PayloadFieldSchema
# {"anyOf" [{"$ref" "#/components/schemas/PayloadSchemaType"} {"$ref" "#/components/schemas/PayloadSchemaParams"}]}

qdrant:PayloadFieldSchema a jsonschema:DataSchema ;
  jsonschema:anyOf (
    qdrant:PayloadSchemaType 
    qdrant:PayloadSchemaParams
    ) .

# PayloadIndexInfo
# {"description" "Display payload field type & index information", "type" "object", "required" ["data_type" "points"], "properties" {"data_type" {"$ref" "#/components/schemas/PayloadSchemaType"}, "params" {"anyOf" [{"$ref" "#/components/schemas/PayloadSchemaParams"} {"nullable" true}]}, "points" {"description" "Number of points indexed with this index", "type" "integer", "format" "uint", "minimum" 0}}}

qdrant:PayloadIndexInfo a jsonschema:ObjectSchema ;
  dcterms:description "Display payload field type & index information" ;
  jsonschema:required ("data_type" "points") ;
  jsonschema:properties [
    jsonschema:propertyName "data_type" ;
    rdf:type qdrant:PayloadSchemaType ;
    ] ,
    [
    jsonschema:propertyName "params" ;
    jsonschema:anyOf (
      qdrant:PayloadSchemaParams 
      jsonschema:NullSchema
      ) ;
    ] ,
    [
    jsonschema:propertyName "points" ;
    dcterms:description "Number of points indexed with this index" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] .

# PayloadIndexTelemetry
# {"type" "object", "required" ["points_count" "points_values_count"], "properties" {"field_name" {"type" "string", "nullable" true}, "points_values_count" {"type" "integer", "format" "uint", "minimum" 0}, "points_count" {"type" "integer", "format" "uint", "minimum" 0}, "histogram_bucket_size" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:PayloadIndexTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required ("points_count" "points_values_count") ;
  jsonschema:properties [
    jsonschema:propertyName "field_name" ;
    rdf:type jsonschema:StringSchema ;
    ] ,
    [
    jsonschema:propertyName "points_values_count" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "points_count" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] ,
    [
    jsonschema:propertyName "histogram_bucket_size" ;
    rdf:type jsonschema:IntegerSchema ;
    jsonschema:format "uint" ;
    jsonschema:minimum 0 ;
    ] .

# PayloadSchemaParams
# {"description" "Payload type with parameters", "anyOf" [{"$ref" "#/components/schemas/TextIndexParams"}]}

qdrant:PayloadSchemaParams a jsonschema:DataSchema ;
  dcterms:description "Payload type with parameters" ;
  jsonschema:anyOf (
    qdrant:TextIndexParams
    ) .

# PayloadSchemaType
# {"description" "All possible names of payload types", "type" "string", "enum" ["keyword" "integer" "float" "geo" "text"]}

qdrant:PayloadSchemaType a jsonschema:StringSchema ;
  dcterms:description "All possible names of payload types" ;
  jsonschema:enum ("keyword" "integer" "float" "geo" "text") .

# PayloadSelector
# {"description" "Specifies how to treat payload selector", "anyOf" [{"$ref" "#/components/schemas/PayloadSelectorInclude"} {"$ref" "#/components/schemas/PayloadSelectorExclude"}]}

qdrant:PayloadSelector a jsonschema:DataSchema ;
  dcterms:description "Specifies how to treat payload selector" ;
  jsonschema:anyOf (
    qdrant:PayloadSelectorInclude 
    qdrant:PayloadSelectorExclude
    ) .

# PayloadSelectorExclude
# {"type" "object", "required" ["exclude"], "properties" {"exclude" {"description" "Exclude this fields from returning payload", "type" "array", "items" {"type" "string"}}}, "additionalProperties" false}

qdrant:PayloadSelectorExclude a jsonschema:ObjectSchema ;
  jsonschema:required ("exclude") ;
  jsonschema:properties ([
    jsonschema:propertyName "exclude" ;
    dcterms:description "Exclude this fields from returning payload" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items jsonschema:StringSchema ;
    ]) .

# PayloadSelectorInclude
# {"type" "object", "required" ["include"], "properties" {"include" {"description" "Only include this payload keys", "type" "array", "items" {"type" "string"}}}, "additionalProperties" false}

qdrant:PayloadSelectorInclude a jsonschema:ObjectSchema ;
  jsonschema:required ("include") ;
  jsonschema:properties ([
    jsonschema:propertyName "include" ;
    dcterms:description "Only include this payload keys" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items jsonschema:StringSchema ;
    ]) .

# PayloadStorageType
# {"description" "Type of payload storage", "oneOf" [{"type" "object", "required" ["type"], "properties" {"type" {"type" "string", "enum" ["in_memory"]}}} {"type" "object", "required" ["type"], "properties" {"type" {"type" "string", "enum" ["on_disk"]}}}]}

qdrant:PayloadStorageType a jsonschema:ObjectSchema ;
  dcterms:description "Type of payload storage" ;
  jsonschema:oneOf [
    jsonschema:propertyName "type" ;
    rdf:type jsonschema:StringSchema ;
    jsonschema:enum ("in_memory") ;
    ] ,
    [
    jsonschema:propertyName "type" ;
    rdf:type jsonschema:StringSchema ;
    jsonschema:enum ("on_disk") ;
    ] .

# PeerInfo
# {"description" "Information of a peer in the cluster", "type" "object", "required" ["uri"], "properties" {"uri" {"type" "string"}}}

qdrant:PeerInfo a jsonschema:ObjectSchema ;
  dcterms:description "Information of a peer in the cluster" ;
  jsonschema:required ("uri") ;
  jsonschema:properties ([
    jsonschema:propertyName "uri" ;
    rdf:type jsonschema:StringSchema ;
    ]) .

# PointGroup
# {"type" "object", "required" ["hits" "id"], "properties" {"hits" {"description" "Scored points that have the same value of the group_by key", "type" "array", "items" {"$ref" "#/components/schemas/ScoredPoint"}}, "id" {"$ref" "#/components/schemas/GroupId"}}}

qdrant:PointGroup a jsonschema:ObjectSchema ;
  jsonschema:required ("hits" "id") ;
  jsonschema:properties [
    jsonschema:propertyName "hits" ;
    dcterms:description "Scored points that have the same value of the group_by key" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ScoredPoint ;
    ] ,
    [
    jsonschema:propertyName "id" ;
    rdf:type jsonschema:StringSchema ;
    ] .

# PointIdsList
# {"type" "object", "required" ["points"], "properties" {"points" {"type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}}}

qdrant:PointIdsList a jsonschema:ObjectSchema ;
  jsonschema:required ("points") ;
  jsonschema:properties ([
    jsonschema:propertyName "points" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    ]) .

# PointInsertOperations
# {"oneOf" [{"$ref" "#/components/schemas/PointsBatch"} {"$ref" "#/components/schemas/PointsList"}]}

qdrant:PointInsertOperations a jsonschema:ObjectSchema ;
  jsonschema:oneOf (
    qdrant:PointsBatch
    qdrant:PointsList
    ) .

# PointRequest
# {"type" "object", "required" ["ids"], "properties" {"ids" {"description" "Look for points with ids", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "with_payload" {"description" "Select which payload to return with the response. Default: All", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "with_vector" {"$ref" "#/components/schemas/WithVector"}}}

qdrant:PointRequest a jsonschema:ObjectSchema ;
  jsonschema:required ("ids") ;
  jsonschema:properties [
    jsonschema:propertyName "ids" ;
    dcterms:description "Look for points with ids" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:ExtendedPointId ;
    ] ,
    [
    jsonschema:propertyName "with_payload" ;
    dcterms:description "Select which payload to return with the response. Default: All" ;
    jsonschema:anyOf (
      qdrant:WithPayloadInterface
      jsonschema:NullSchema 
      ) ;
    ] ,
    [
    jsonschema:propertyName "with_vector" ;
    rdf:type qdrant:WithVector ;
    ] .

# PointStruct
# {"type" "object", "required" ["id" "vector"], "properties" {"id" {"$ref" "#/components/schemas/ExtendedPointId"}, "vector" {"$ref" "#/components/schemas/VectorStruct"}, "payload" {"description" "Payload values (optional)", "anyOf" [{"$ref" "#/components/schemas/Payload"} {"nullable" true}]}}}

qdrant:PointStruct a jsonschema:ObjectSchema ;
  jsonschema:required ("id" "vector") ;
  jsonschema:properties [
    jsonschema:propertyName "id" ;
    rdf:type qdrant:ExtendedPointId ;
    ] ,
    [
    jsonschema:propertyName "vector" ;
    rdf:type qdrant:VectorStruct ;
    ] ,
    [
    jsonschema:propertyName "payload" ;
    dcterms:description "Payload values (optional)" ;
    jsonschema:anyOf (
      qdrant:Payload
      jsonschema:NullSchema 
      ) ;
    ] .

# PointVectors
# {"type" "object", "required" ["id" "vector"], "properties" {"id" {"$ref" "#/components/schemas/ExtendedPointId"}, "vector" {"$ref" "#/components/schemas/VectorStruct"}}}

qdrant:PointVectors a jsonschema:ObjectSchema ;
  jsonschema:required ("id" "vector") ;
  jsonschema:properties [
    jsonschema:propertyName "id" ;
    rdf:type qdrant:ExtendedPointId ;
    ] ,
    [
    jsonschema:propertyName "vector" ;
    rdf:type qdrant:VectorStruct ;
    ] .

# PointsBatch
# {"required" ["batch"], "properties" {"batch" {"$ref" "#/components/schemas/Batch"}}}

qdrant:PointsBatch a jsonschema:ObjectSchema ;
  jsonschema:required ("batch") ;
  jsonschema:properties ([
    jsonschema:propertyName "batch" ;
    rdf:type qdrant:Batch ;
    ]) .

# PointsList
# {"type" "object", "required" ["points"], "properties" {"points" {"type" "array", "items" {"$ref" "#/components/schemas/PointStruct"}}}}

qdrant:PointsList a jsonschema:ObjectSchema ;
  jsonschema:required ("points") ;
  jsonschema:properties ([
    jsonschema:propertyName "points" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:PointStruct ;
    ]) .

# PointsSelector
# {"anyOf" [{"$ref" "#/components/schemas/PointIdsList"} {"$ref" "#/components/schemas/FilterSelector"}]}

qdrant:PointsSelector a jsonschema:DataSchema ;
  jsonschema:anyOf (
    qdrant:PointIdsList
    qdrant:FilterSelector
    ) .

# ProductQuantization
# {"type" "object", "required" ["product"], "properties" {"product" {"$ref" "#/components/schemas/ProductQuantizationConfig"}}}

qdrant:ProductQuantization a jsonschema:ObjectSchema ;
  jsonschema:required ("product") ;
  jsonschema:properties (
    [ jsonschema:propertyName "product" ;
      rdf:type qdrant:ProductQuantizationConfig ;
      ]
    ) .

# ProductQuantizationConfig
# {"type" "object", "required" ["compression"], "properties" {"compression" {"$ref" "#/components/schemas/CompressionRatio"}, "always_ram" {"type" "boolean", "nullable" true}}}

qdrant:ProductQuantizationConfig a jsonschema:ObjectSchema ;
  jsonschema:required ("compression") ;
  jsonschema:properties [
    jsonschema:propertyName "compression" ;
    rdf:type qdrant:CompressionRatio ;
    ] ,
    [
    jsonschema:propertyName "always_ram" ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# QuantizationConfig
# {"anyOf" [{"$ref" "#/components/schemas/ScalarQuantization"} {"$ref" "#/components/schemas/ProductQuantization"}]}

qdrant:QuantizationConfig a jsonschema:DataSchema ;
  jsonschema:anyOf (
    qdrant:ScalarQuantization
    qdrant:ProductQuantization
    ) .

# QuantizationSearchParams
# {"description" "Additional parameters of the search", "type" "object", "properties" {"ignore" {"description" "If true, quantized vectors are ignored. Default is false.", "default" false, "type" "boolean"}, "rescore" {"description" "If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false.", "default" false, "type" "boolean"}}}

qdrant:QuantizationSearchParams a jsonschema:ObjectSchema ;
  dcterms:description "Additional parameters of the search" ;
  jsonschema:properties [
    jsonschema:propertyName "ignore" ;
    dcterms:description "If true, quantized vectors are ignored. Default is false." ;
    jsonschema:default false ;
    rdf:type jsonschema:BooleanSchema ;
    ] ,
    [
    jsonschema:propertyName "rescore" ;
    dcterms:description "If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false." ;
    jsonschema:default false ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# RaftInfo
# {"description" "Summary information about the current raft state", "type" "object", "required" ["commit" "is_voter" "pending_operations" "term"], "properties" {"term" {"description" "Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.", "type" "integer", "format" "uint64", "minimum" 0}, "commit" {"description" "The index of the latest committed (finalized) operation that this peer is aware of.", "type" "integer", "format" "uint64", "minimum" 0}, "pending_operations" {"description" "Number of consensus operations pending to be applied on this peer", "type" "integer", "format" "uint", "minimum" 0}, "leader" {"description" "Leader of the current term", "type" "integer", "format" "uint64", "minimum" 0, "nullable" true}, "role" {"description" "Role of this peer in the current term", "anyOf" [{"$ref" "#/components/schemas/StateRole"} {"nullable" true}]}, "is_voter" {"description" "Is this peer a voter or a learner", "type" "boolean"}}}

qdrant:RaftInfo a jsonschema:ObjectSchema ;
  dcterms:description "Summary information about the current raft state" ;
  jsonschema:required ("commit" "is_voter" "pending_operations" "term") ;
  jsonschema:properties [
    jsonschema:propertyName "term" ;
    dcterms:description "Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication." ;
    jsonschema:minimum 0 ;
    rdf:type jsonschema:IntegerSchema ;
    ] ,
    [
    jsonschema:propertyName "commit" ;
    dcterms:description "The index of the latest committed (finalized) operation that this peer is aware of." ;
    jsonschema:minimum 0 ;
    rdf:type jsonschema:IntegerSchema ;
    ] ,
    [
    jsonschema:propertyName "pending_operations" ;
    dcterms:description "Number of consensus operations pending to be applied on this peer" ;
    jsonschema:minimum 0 ;
    rdf:type jsonschema:IntegerSchema ;
    ] ,
    [
    jsonschema:propertyName "leader" ;
    dcterms:description "Leader of the current term" ;
    jsonschema:minimum 0 ;
    rdf:type jsonschema:IntegerSchema ;
    ] ,
    [
    jsonschema:propertyName "role" ;
    dcterms:description "Role of this peer in the current term" ;
    jsonschema:anyOf (
      qdrant:StateRole
      ) ;
    ] ,
    [
    jsonschema:propertyName "is_voter" ;
    dcterms:description "Is this peer a voter or a learner" ;
    rdf:type jsonschema:BooleanSchema ;
    ] .

# Range
# {"description" "Range filter request", "type" "object", "properties" {"lt" {"description" "point.key < range.lt", "type" "number", "format" "double", "nullable" true}, "gt" {"description" "point.key > range.gt", "type" "number", "format" "double", "nullable" true}, "gte" {"description" "point.key >= range.gte", "type" "number", "format" "double", "nullable" true}, "lte" {"description" "point.key <= range.lte", "type" "number", "format" "double", "nullable" true}}}

qdrant:Range a jsonschema:ObjectSchema ;
  dcterms:description "Range filter request" ;
  jsonschema:properties [
    jsonschema:propertyName "lt" ;
    jsonschema:format "double" ;
    dcterms:description "point.key < range.lt" ;
    rdf:type jsonschema:NumberSchema ;
    ] ,
    [
    jsonschema:propertyName "gt" ;
    jsonschema:format "double" ;
    dcterms:description "point.key > range.gt" ;
    rdf:type jsonschema:NumberSchema ;
    ] ,
    [
    jsonschema:propertyName "gte" ;
    jsonschema:format "double" ;
    dcterms:description "point.key >= range.gte" ;
    rdf:type jsonschema:NumberSchema ;
    ] ,
    [
    jsonschema:propertyName "lte" ;
    jsonschema:format "double" ;
    dcterms:description "point.key <= range.lte" ;
    rdf:type jsonschema:NumberSchema ;
    ] .

# ReadConsistency
# {"description" "Read consistency parameter\n\nDefines how many replicas should be queried to get the result\n\n* `N` - send N random request and return points, which present on all of them\n\n* `majority` - send N/2+1 random request and return points, which present on all of them\n\n* `quorum` - send requests to all nodes and return points which present on majority of them\n\n* `all` - send requests to all nodes and return points which present on all of them\n\nDefault value is `Factor(1)`", "anyOf" [{"type" "integer", "format" "uint", "minimum" 0} {"$ref" "#/components/schemas/ReadConsistencyType"}]}

qdrant:ReadConsistency a jsonschema:ObjectSchema ;
  dcterms:description "Read consistency parameter. Defines how many replicas should be queried to get the result. `N` - send N random request and return points, which present on all of them. `majority` - send N/2+1 random request and return points, which present on all of them. `quorum` - send requests to all nodes and return points which present on majority of them. `all` - send requests to all nodes and return points which present on all of them. Default value is `Factor(1)`" ;
  jsonschema:anyOf (
    [
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    qdrant:ReadConsistencyType
    ) .

# ReadConsistencyType
# {"description" "* `majority` - send N/2+1 random request and return points, which present on all of them\n\n* `quorum` - send requests to all nodes and return points which present on majority of nodes\n\n* `all` - send requests to all nodes and return points which present on all nodes", "type" "string", "enum" ["majority" "quorum" "all"]}

qdrant:ReadConsistencyType a jsonschema:StringSchema ;
  dcterms:description "majority - send N/2+1 random request and return points, which present on all of them. quorum - send requests to all nodes and return points which present on majority of nodes. all - send requests to all nodes and return points which present on all nodes" ;
  jsonschema:enum (
    "majority"
    "quorum"
    "all"
    ) .

# RecommendGroupsRequest
# {"type" "object", "required" ["group_by" "group_size" "limit" "positive"], "properties" {"using" {"description" "Define which vector to use for recommendation, if not specified - try to use default vector", "default" nil, "anyOf" [{"$ref" "#/components/schemas/UsingVector"} {"nullable" true}]}, "positive" {"description" "Look for vectors closest to those", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "params" {"description" "Additional search params", "anyOf" [{"$ref" "#/components/schemas/SearchParams"} {"nullable" true}]}, "lookup_from" {"description" "The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection", "default" nil, "anyOf" [{"$ref" "#/components/schemas/LookupLocation"} {"nullable" true}]}, "negative" {"description" "Try to avoid vectors like this", "default" [], "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "limit" {"description" "Maximum amount of groups to return", "type" "integer", "format" "uint32", "minimum" 1}, "with_payload" {"description" "Select which payload to return with the response. Default: None", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "filter" {"description" "Look only for points which satisfies this conditions", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "group_size" {"description" "Maximum amount of points to return per group", "type" "integer", "format" "uint32", "minimum" 1}, "score_threshold" {"description" "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.", "type" "number", "format" "float", "nullable" true}, "with_vector" {"description" "Whether to return the point vector with the result?", "default" nil, "anyOf" [{"$ref" "#/components/schemas/WithVector"} {"nullable" true}]}, "group_by" {"description" "Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.", "type" "string", "minLength" 1}}}

qdrant:RecommendGroupsRequest a jsonschema:ObjectSchema ;
  dcterms:description "Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection. Service should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate." ;
  jsonschema:required (
    "group_by"
    "group_size"
    "limit"
    "positive"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "using" ;
      dcterms:description "Define which vector to use for recommendation, if not specified - try to use default vector" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:UsingVector
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "positive" ;
      dcterms:description "Look for vectors closest to those" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        qdrant:ExtendedPointId
        ) ;
      ]
    [
      jsonschema:propertyName "params" ;
      dcterms:description "Additional search params" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:SearchParams
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "lookup_from" ;
      dcterms:description "The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:LookupLocation
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "negative" ;
      dcterms:description "Try to avoid vectors like this" ;
      jsonschema:default "[]" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        qdrant:ExtendedPointId
        ) ;
      ]
    [
      jsonschema:propertyName "limit" ;
      dcterms:description "Maximum amount of groups to return" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 1 ;
      ]
    [ 
      jsonschema:propertyName "with_payload" ;
      rdf:type jsonschema:ObjectSchema ;
      dcterms:description "Select which payload to return with the response. Default: None" ;
      jsonschema:anyOf (
        qdrant:WithPayloadInterface
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "filter" ;
      dcterms:description "Look only for points which satisfies this conditions" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:Filter
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "group_size" ;
      dcterms:description "Maximum amount of points to return per group" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "score_threshold" ;
      dcterms:description "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned." ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      ]
    [
      jsonschema:propertyName "with_vector" ;
      dcterms:description "Whether to return the point vector with the result?" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:WithVector
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "group_by" ;
      dcterms:description "Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups." ;
      rdf:type jsonschema:StringSchema ;
      jsonschema:minLength 1 ;
      ]
    ) .

# RecommendRequest
# {"description" "Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection.\n\nService should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate.", "type" "object", "required" ["limit" "positive"], "properties" {"using" {"description" "Define which vector to use for recommendation, if not specified - try to use default vector", "default" nil, "anyOf" [{"$ref" "#/components/schemas/UsingVector"} {"nullable" true}]}, "positive" {"description" "Look for vectors closest to those", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "offset" {"description" "Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.", "default" 0, "type" "integer", "format" "uint", "minimum" 0}, "params" {"description" "Additional search params", "anyOf" [{"$ref" "#/components/schemas/SearchParams"} {"nullable" true}]}, "lookup_from" {"description" "The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection", "default" nil, "anyOf" [{"$ref" "#/components/schemas/LookupLocation"} {"nullable" true}]}, "negative" {"description" "Try to avoid vectors like this", "default" [], "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}}, "limit" {"description" "Max number of result to return", "type" "integer", "format" "uint", "minimum" 0}, "with_payload" {"description" "Select which payload to return with the response. Default: None", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "filter" {"description" "Look only for points which satisfies this conditions", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "score_threshold" {"description" "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.", "type" "number", "format" "float", "nullable" true}, "with_vector" {"description" "Whether to return the point vector with the result?", "default" nil, "anyOf" [{"$ref" "#/components/schemas/WithVector"} {"nullable" true}]}}}

qdrant:RecommendRequest a jsonschema:ObjectSchema ;
  jsonschema:required (
    "limit"
    "positive"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "using" ;
      dcterms:description "Define which vector to use for recommendation, if not specified - try to use default vector" ;
      jsonschema:default "null" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:UsingVector
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "positive" ;
      dcterms:description "Look for vectors closest to those" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        qdrant:ExtendedPointId
        ) ;
      ]
    [
      jsonschema:propertyName "offset" ;
      dcterms:description "Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues." ;
      jsonschema:default 0 ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "params" ;
      dcterms:description "Additional search params" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:SearchParams
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "lookup_from" ;
      dcterms:description "The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection" ;
      jsonschema:default "null" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:LookupLocation
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "negative" ;
      dcterms:description "Try to avoid vectors like this" ;
      jsonschema:default "[]" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        qdrant:ExtendedPointId
        ) ;
      ]
    [
      jsonschema:propertyName "limit" ;
      dcterms:description "Max number of result to return" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ] 
    [
      jsonschema:propertyName "with_payload" ;
      dcterms:description "Select which payload to return with the response. Default: None" ;
      jsonschema:default "null" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:WithPayloadInterface
        jsonschema:NullSchema
        ) ;
      ] 
    [
      jsonschema:propertyName "filter" ;
      dcterms:description "Look only for points which satisfies this conditions" ;
      jsonschema:default "null" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:Filter
        jsonschema:NullSchema
        ) ;
      ] 
    [
      jsonschema:propertyName "score_threshold" ;
      dcterms:description "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned." ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      jsonschema:minimum 0 ;
      jsonschema:exclusiveMinimum true ;
      jsonschema:default "null" ;
      ] 
    [
      jsonschema:propertyName "with_vector" ;
      dcterms:description "Whether to return the point vector with the result?" ;
      jsonschema:default "null" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:WithVector
        jsonschema:NullSchema
        ) ;
      ] 
    ) .

# RecommendRequestBatch
# {"type" "object", "required" ["searches"], "properties" {"searches" {"type" "array", "items" {"$ref" "#/components/schemas/RecommendRequest"}}}}

qdrant:RecommendRequestBatch a jsonschema:ObjectSchema ;
  jsonschema:required (
    "searches"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "searches" ;
      dcterms:description "List of recommendation requests" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        qdrant:RecommendRequest
        ) ;
      ]
    ) .

# Record
# {"description" "Point data", "type" "object", "required" ["id"], "properties" {"id" {"$ref" "#/components/schemas/ExtendedPointId"}, "payload" {"description" "Payload - values assigned to the point", "anyOf" [{"$ref" "#/components/schemas/Payload"} {"nullable" true}]}, "vector" {"description" "Vector of the point", "anyOf" [{"$ref" "#/components/schemas/VectorStruct"} {"nullable" true}]}}}

qdrant:Record a jsonschema:ObjectSchema ;
  jsonschema:required (
    "id"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "id" ;
      dcterms:description "Point id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "payload" ;
      dcterms:description "Payload - values assigned to the point" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:Payload
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "vector" ;
      dcterms:description "Vector of the point" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:VectorStruct
        jsonschema:NullSchema
        ) ;
      ]
    ) .

# RemoteShardInfo
# {"type" "object", "required" ["peer_id" "shard_id" "state"], "properties" {"shard_id" {"description" "Remote shard id", "type" "integer", "format" "uint32", "minimum" 0}, "peer_id" {"description" "Remote peer id", "type" "integer", "format" "uint64", "minimum" 0}, "state" {"$ref" "#/components/schemas/ReplicaState"}}}

qdrant:RemoteShardInfo a jsonschema:ObjectSchema ;
  jsonschema:required (
    "peer_id"
    "shard_id"
    "state"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "shard_id" ;
      dcterms:description "Remote shard id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "peer_id" ;
      dcterms:description "Remote peer id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "state" ;
      rdf:type qdrant:ReplicaState ;
      ]
    ) .

# RemoteShardTelemetry
# {"type" "object", "required" ["searches" "shard_id" "updates"], "properties" {"shard_id" {"type" "integer", "format" "uint32", "minimum" 0}, "peer_id" {"type" "integer", "format" "uint64", "minimum" 0, "nullable" true}, "searches" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "updates" {"$ref" "#/components/schemas/OperationDurationStatistics"}}}

qdrant:RemoteShardTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "searches"
    "shard_id"
    "updates"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "shard_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "peer_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "searches" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "updates" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    ) .

# RenameAlias
# {"description" "Change alias to a new one", "type" "object", "required" ["new_alias_name" "old_alias_name"], "properties" {"old_alias_name" {"type" "string"}, "new_alias_name" {"type" "string"}}}

qdrant:RenameAlias a jsonschema:ObjectSchema ;
  dcterms:description "Change alias to a new one" ;
  jsonschema:required (
    "new_alias_name"
    "old_alias_name"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "old_alias_name" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "new_alias_name" ;
      rdf:type jsonschema:StringSchema ;
      ]
    ) .

# RenameAliasOperation
# {"description" "Change alias to a new one", "type" "object", "required" ["rename_alias"], "properties" {"rename_alias" {"$ref" "#/components/schemas/RenameAlias"}}}

qdrant:RenameAliasOperation a jsonschema:ObjectSchema ;
  dcterms:description "Change alias to a new one" ;
  jsonschema:required (
    "rename_alias"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "rename_alias" ;
      rdf:type qdrant:RenameAlias ;
      ]
    ) .

# Replica
# {"type" "object", "required" ["peer_id" "shard_id"], "properties" {"shard_id" {"type" "integer", "format" "uint32", "minimum" 0}, "peer_id" {"type" "integer", "format" "uint64", "minimum" 0}}}

qdrant:Replica a jsonschema:ObjectSchema ;
  jsonschema:required (
    "peer_id"
    "shard_id"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "shard_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "peer_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# ReplicaSetTelemetry
# {"type" "object", "required" ["id" "remote" "replicate_states"], "properties" {"id" {"type" "integer", "format" "uint32", "minimum" 0}, "local" {"anyOf" [{"$ref" "#/components/schemas/LocalShardTelemetry"} {"nullable" true}]}, "remote" {"type" "array", "items" {"$ref" "#/components/schemas/RemoteShardTelemetry"}}, "replicate_states" {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/ReplicaState"}}}}

qdrant:ReplicaSetTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "id"
    "remote"
    "replicate_states"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 0 ;
      ]
    [
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:propertyName "local" ;
      jsonschema:anyOf (
        qdrant:LocalShardTelemetry
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "remote" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:RemoteShardTelemetry ;
      ]
    [
      jsonschema:propertyName "replicate_states" ;
      rdf:type qdrant:ReplicaState ;
      ]
    ) .

# ReplicaState
# {"description" "State of the single shard within a replica set.", "type" "string", "enum" ["Active" "Dead" "Partial" "Initializing" "Listener"]}

qdrant:ReplicaState a jsonschema:StringSchema ;
  dcterms:description "State of the single shard within a replica set." ;
  jsonschema:enum (
    "Active"
    "Dead"
    "Partial"
    "Initializing"
    "Listener"
    ) .

# ReplicateShardOperation
# {"type" "object", "required" ["replicate_shard"], "properties" {"replicate_shard" {"$ref" "#/components/schemas/MoveShard"}}}

qdrant:ReplicateShardOperation a jsonschema:ObjectSchema ;
  jsonschema:required (
    "replicate_shard"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "replicate_shard" ;
      rdf:type qdrant:MoveShard ;
      ]
    ) .

# RequestsTelemetry
# {"type" "object", "required" ["grpc" "rest"], "properties" {"rest" {"$ref" "#/components/schemas/WebApiTelemetry"}, "grpc" {"$ref" "#/components/schemas/GrpcTelemetry"}}}

qdrant:RequestsTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "grpc"
    "rest"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "rest" ;
      rdf:type qdrant:WebApiTelemetry ;
      ]
    [
      jsonschema:propertyName "grpc" ;
      rdf:type qdrant:GrpcTelemetry ;
      ]
    ) .

# RunningEnvironmentTelemetry
# {"type" "object", "required" ["cpu_flags" "is_docker"], "properties" {"distribution" {"type" "string", "nullable" true}, "distribution_version" {"type" "string", "nullable" true}, "is_docker" {"type" "boolean"}, "cores" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "ram_size" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "disk_size" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "cpu_flags" {"type" "string"}}}

qdrant:RunningEnvironmentTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "cpu_flags"
    "is_docker"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "distribution" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "distribution_version" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "is_docker" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "cores" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "ram_size" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "disk_size" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "cpu_flags" ;
      rdf:type jsonschema:StringSchema ;
      ]
    ) .

# ScalarQuantization
# {"type" "object", "required" ["scalar"], "properties" {"scalar" {"$ref" "#/components/schemas/ScalarQuantizationConfig"}}}

qdrant:ScalarQuantization a jsonschema:ObjectSchema ;
  jsonschema:required (
    "scalar"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "scalar" ;
      rdf:type qdrant:ScalarQuantizationConfig ;
      ]
    ) .

# ScalarQuantizationConfig
# {"type" "object", "required" ["type"], "properties" {"type" {"$ref" "#/components/schemas/ScalarType"}, "quantile" {"description" "Quantile for quantization. Expected value range in [0.5, 1.0]. If not set - use the whole range of values", "type" "number", "format" "float", "maximum" 1, "minimum" 0.5, "nullable" true}, "always_ram" {"description" "If true - quantized vectors always will be stored in RAM, ignoring the config of main storage", "type" "boolean", "nullable" true}}}

qdrant:ScalarQuantizationConfig a jsonschema:ObjectSchema ;
  jsonschema:required (
    "type"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "type" ;
      rdf:type qdrant:ScalarType ;
      ]
    [
      jsonschema:propertyName "quantile" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      jsonschema:maximum 1 ;
      jsonschema:minimum 0.5 ;
      ]
    [
      jsonschema:propertyName "always_ram" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    ) .

# ScalarType
# {"type" "string", "enum" ["int8"]}

qdrant:ScalarType a jsonschema:StringSchema ;
  jsonschema:enum (
    "int8"
    ) .

# ScoredPoint
# {"description" "Search result", "type" "object", "required" ["id" "score" "version"], "properties" {"id" {"$ref" "#/components/schemas/ExtendedPointId"}, "version" {"description" "Point version", "type" "integer", "format" "uint64", "minimum" 0}, "score" {"description" "Points vector distance to the query vector", "type" "number", "format" "float"}, "payload" {"description" "Payload - values assigned to the point", "anyOf" [{"$ref" "#/components/schemas/Payload"} {"nullable" true}]}, "vector" {"description" "Vector of the point", "anyOf" [{"$ref" "#/components/schemas/VectorStruct"} {"nullable" true}]}}}

qdrant:ScoredPoint a jsonschema:ObjectSchema ;
  jsonschema:required (
    "id"
    "score"
    "version"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "id" ;
      rdf:type qdrant:ExtendedPointId ;
      ]
    [
      jsonschema:propertyName "version" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "score" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      ]
    [
      jsonschema:propertyName "payload" ;
      rdf:type qdrant:Payload ;
      ]
    [
      jsonschema:propertyName "vector" ;
      rdf:type qdrant:VectorStruct ;
      ]
    ) .

# ScrollRequest
# {"description" "Scroll request - paginate over all points which matches given condition", "type" "object", "properties" {"offset" {"description" "Start ID to read points from.", "anyOf" [{"$ref" "#/components/schemas/ExtendedPointId"} {"nullable" true}]}, "limit" {"description" "Page size. Default: 10", "type" "integer", "format" "uint", "minimum" 1, "nullable" true}, "filter" {"description" "Look only for points which satisfies this conditions. If not provided - all points.", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "with_payload" {"description" "Select which payload to return with the response. Default: All", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "with_vector" {"$ref" "#/components/schemas/WithVector"}}}

qdrant:ScrollRequest a jsonschema:ObjectSchema ;
  jsonschema:properties (
    [
      jsonschema:propertyName "offset" ;
      rdf:type qdrant:ExtendedPointId ;
      ]
    [
      jsonschema:propertyName "limit" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "filter" ;
      rdf:type qdrant:Filter ;
      ]
    [
      jsonschema:propertyName "with_payload" ;
      rdf:type qdrant:WithPayloadInterface ;
      ]
    [
      jsonschema:propertyName "with_vector" ;
      rdf:type qdrant:WithVector ;
      ]
    ) .

# ScrollResult
# {"description" "Result of the points read request", "type" "object", "required" ["points"], "properties" {"points" {"description" "List of retrieved points", "type" "array", "items" {"$ref" "#/components/schemas/Record"}}, "next_page_offset" {"description" "Offset which should be used to retrieve a next page result", "anyOf" [{"$ref" "#/components/schemas/ExtendedPointId"} {"nullable" true}]}}}

qdrant:ScrollResult a jsonschema:ObjectSchema ;
  jsonschema:required (
    "points"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "points" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:Record ;
      ]
    [
      jsonschema:propertyName "next_page_offset" ;
      rdf:type qdrant:ExtendedPointId ;
      ]
    ) .

# SearchGroupsRequest
# {"type" "object", "required" ["group_by" "group_size" "limit" "vector"], "properties" {"params" {"description" "Additional search params", "anyOf" [{"$ref" "#/components/schemas/SearchParams"} {"nullable" true}]}, "limit" {"description" "Maximum amount of groups to return", "type" "integer", "format" "uint32", "minimum" 1}, "vector" {"$ref" "#/components/schemas/NamedVectorStruct"}, "with_payload" {"description" "Select which payload to return with the response. Default: None", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "filter" {"description" "Look only for points which satisfies this conditions", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "group_size" {"description" "Maximum amount of points to return per group", "type" "integer", "format" "uint32", "minimum" 1}, "score_threshold" {"description" "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.", "type" "number", "format" "float", "nullable" true}, "with_vector" {"description" "Whether to return the point vector with the result?", "default" nil, "anyOf" [{"$ref" "#/components/schemas/WithVector"} {"nullable" true}]}, "group_by" {"description" "Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.", "type" "string", "minLength" 1}}}

qdrant:SearchGroupsRequest a jsonschema:ObjectSchema ;
  jsonschema:required (
    "group_by"
    "group_size"
    "limit"
    "vector"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "params" ;
      rdf:type qdrant:SearchParams ;
      ]
    [
      jsonschema:propertyName "limit" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "vector" ;
      rdf:type qdrant:NamedVectorStruct ;
      ]
    [
      jsonschema:propertyName "with_payload" ;
      rdf:type qdrant:WithPayloadInterface ;
      ]
    [
      jsonschema:propertyName "filter" ;
      rdf:type qdrant:Filter ;
      ]
    [
      jsonschema:propertyName "group_size" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "score_threshold" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      ]
    [
      jsonschema:propertyName "with_vector" ;
      rdf:type qdrant:WithVector ;
      ]
    [
      jsonschema:propertyName "group_by" ;
      rdf:type jsonschema:StringSchema ;
      jsonschema:minLength 1 ;
      ]
    ) .

# SearchParams
# {"description" "Additional parameters of the search", "type" "object", "properties" {"hnsw_ef" {"description" "Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "exact" {"description" "Search without approximation. If set to true, search may run long but with exact results.", "default" false, "type" "boolean"}, "quantization" {"description" "Quantization params", "default" nil, "anyOf" [{"$ref" "#/components/schemas/QuantizationSearchParams"} {"nullable" true}]}}}

qdrant:SearchParams a jsonschema:ObjectSchema ;
  jsonschema:properties (
    [
      jsonschema:propertyName "hnsw_ef" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "exact" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "quantization" ;
      rdf:type qdrant:QuantizationSearchParams ;
      ]
    ) .

# SearchRequest
# {"description" "Search request. Holds all conditions and parameters for the search of most similar points by vector similarity given the filtering restrictions.", "type" "object", "required" ["limit" "vector"], "properties" {"vector" {"$ref" "#/components/schemas/NamedVectorStruct"}, "filter" {"description" "Look only for points which satisfies this conditions", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}, "params" {"description" "Additional search params", "anyOf" [{"$ref" "#/components/schemas/SearchParams"} {"nullable" true}]}, "limit" {"description" "Max number of result to return", "type" "integer", "format" "uint", "minimum" 0}, "offset" {"description" "Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.", "default" 0, "type" "integer", "format" "uint", "minimum" 0}, "with_payload" {"description" "Select which payload to return with the response. Default: None", "anyOf" [{"$ref" "#/components/schemas/WithPayloadInterface"} {"nullable" true}]}, "with_vector" {"description" "Whether to return the point vector with the result?", "default" nil, "anyOf" [{"$ref" "#/components/schemas/WithVector"} {"nullable" true}]}, "score_threshold" {"description" "Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.", "type" "number", "format" "float", "nullable" true}}}

qdrant:SearchRequest a jsonschema:ObjectSchema ;
  jsonschema:required (
    "limit"
    "vector"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "vector" ;
      rdf:type qdrant:NamedVectorStruct ;
      ]
    [
      jsonschema:propertyName "filter" ;
      rdf:type qdrant:Filter ;
      ]
    [
      jsonschema:propertyName "params" ;
      rdf:type qdrant:SearchParams ;
      ]
    [
      jsonschema:propertyName "limit" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "offset" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "with_payload" ;
      rdf:type qdrant:WithPayloadInterface ;
      ]
    [
      jsonschema:propertyName "with_vector" ;
      rdf:type qdrant:WithVector ;
      ]
    [
      jsonschema:propertyName "score_threshold" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "float" ;
      ]
    ) .

# SearchRequestBatch
# {"type" "object", "required" ["searches"], "properties" {"searches" {"type" "array", "items" {"$ref" "#/components/schemas/SearchRequest"}}}}

qdrant:SearchRequestBatch a jsonschema:ObjectSchema ;
  jsonschema:required (
    "searches"
    ) ;
  jsonschema:properties
  ([
    jsonschema:propertyName "searches" ;
    rdf:type jsonschema:ArraySchema ;
    jsonschema:items qdrant:SearchRequest ; 
    ]) .

# SegmentConfig
# {"type" "object", "required" ["payload_storage_type" "vector_data"], "properties" {"vector_data" {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/VectorDataConfig"}}, "payload_storage_type" {"$ref" "#/components/schemas/PayloadStorageType"}}}

qdrant:SegmentConfig a jsonschema:ObjectSchema ;
  jsonschema:required (
    "payload_storage_type"
    "vector_data"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "vector_data" ;
      rdf:type qdrant:VectorDataConfig ;
      ]
    [
      jsonschema:propertyName "payload_storage_type" ;
      rdf:type qdrant:PayloadStorageType ;
      ]
    ) .

# SegmentInfo
# {"description" "Aggregated information about segment", "type" "object", "required" ["disk_usage_bytes" "index_schema" "is_appendable" "num_deleted_vectors" "num_points" "num_vectors" "ram_usage_bytes" "segment_type"], "properties" {"segment_type" {"$ref" "#/components/schemas/SegmentType"}, "num_vectors" {"type" "integer", "format" "uint", "minimum" 0}, "num_points" {"type" "integer", "format" "uint", "minimum" 0}, "num_deleted_vectors" {"type" "integer", "format" "uint", "minimum" 0}, "ram_usage_bytes" {"type" "integer", "format" "uint", "minimum" 0}, "disk_usage_bytes" {"type" "integer", "format" "uint", "minimum" 0}, "is_appendable" {"type" "boolean"}, "index_schema" {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/PayloadIndexInfo"}}}}

qdrant:SegmentInfo a jsonschema:ObjectSchema ;
  jsonschema:required (
    "disk_usage_bytes"
    "index_schema"
    "is_appendable"
    "num_deleted_vectors"
    "num_points"
    "num_vectors"
    "ram_usage_bytes"
    "segment_type"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "segment_type" ;
      rdf:type qdrant:SegmentType ;
      ]
    [
      jsonschema:propertyName "num_vectors" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "num_points" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "num_deleted_vectors" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "ram_usage_bytes" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "disk_usage_bytes" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "is_appendable" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "index_schema" ;
      rdf:type qdrant:PayloadIndexInfo ;
      ]
    ) .

# SegmentTelemetry
# {"type" "object", "required" ["config" "info" "payload_field_indices" "vector_index_searches"], "properties" {"info" {"$ref" "#/components/schemas/SegmentInfo"}, "config" {"$ref" "#/components/schemas/SegmentConfig"}, "vector_index_searches" {"type" "array", "items" {"$ref" "#/components/schemas/VectorIndexSearchesTelemetry"}}, "payload_field_indices" {"type" "array", "items" {"$ref" "#/components/schemas/PayloadIndexTelemetry"}}}}

qdrant:SegmentTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "config"
    "info"
    "payload_field_indices"
    "vector_index_searches"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "info" ;
      rdf:type qdrant:SegmentInfo ;
      ]
    [
      jsonschema:propertyName "config" ;
      rdf:type qdrant:SegmentConfig ;
      ]
    [
      jsonschema:propertyName "vector_index_searches" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:VectorIndexSearchesTelemetry ;
      ]
    [
      jsonschema:propertyName "payload_field_indices" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:PayloadIndexTelemetry ;
      ]
    ) .

# SegmentType
# {"description" "Type of segment", "type" "string", "enum" ["plain" "indexed" "special"]}

qdrant:SegmentType a jsonschema:StringSchema ;
  jsonschema:enum (
    "plain"
    "indexed"
    "special"
    ) .

# SetPayload
# {"type" "object", "required" ["payload"], "properties" {"payload" {"$ref" "#/components/schemas/Payload"}, "points" {"description" "Assigns payload to each point in this list", "type" "array", "items" {"$ref" "#/components/schemas/ExtendedPointId"}, "nullable" true}, "filter" {"description" "Assigns payload to each point that satisfy this filter condition", "anyOf" [{"$ref" "#/components/schemas/Filter"} {"nullable" true}]}}}

qdrant:SetPayload a jsonschema:ObjectSchema ;
  jsonschema:required (
    "payload"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "payload" ;
      rdf:type qdrant:Payload ;
      ]
    [
      jsonschema:propertyName "points" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:ExtendedPointId ;
      ]
    [
      jsonschema:propertyName "filter" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:Filter
        jsonschema:NullSchema
        ) ;
      ]
    ) .

# ShardTransferInfo
# {"type" "object", "required" ["from" "shard_id" "sync" "to"], "properties" {"shard_id" {"type" "integer", "format" "uint32", "minimum" 0}, "from" {"type" "integer", "format" "uint64", "minimum" 0}, "to" {"type" "integer", "format" "uint64", "minimum" 0}, "sync" {"description" "If `true` transfer is a synchronization of a replicas If `false` transfer is a moving of a shard from one peer to another", "type" "boolean"}}}

qdrant:ShardTransferInfo a jsonschema:ObjectSchema ;
  jsonschema:required (
    "from"
    "shard_id"
    "sync"
    "to"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "shard_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint32" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "from" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "to" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "sync" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    ) .

# SnapshotDescription
# {"type" "object", "required" ["name" "size"], "properties" {"name" {"type" "string"}, "creation_time" {"type" "string", "format" "partial-date-time", "nullable" true}, "size" {"type" "integer", "format" "uint64", "minimum" 0}}}

qdrant:SnapshotDescription a jsonschema:ObjectSchema ;
  jsonschema:required (
    "name"
    "size"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "name" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "creation_time" ;
      rdf:type jsonschema:StringSchema ;
      jsonschema:format "partial-date-time" ;
      ]
    [
      jsonschema:propertyName "size" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# SnapshotPriority
# {"description" "Defines source of truth for snapshot recovery `Snapshot` means - prefer snapshot data over the current state `Replica` means - prefer existing data over the snapshot", "type" "string", "enum" ["snapshot" "replica"]}

qdrant:SnapshotPriority a jsonschema:StringSchema ;
  jsonschema:enum (
    "snapshot"
    "replica"
    ) .

# SnapshotRecover
# {"type" "object", "required" ["location"], "properties" {"location" {"description" "Examples: - URL `http://localhost:8080/collections/my_collection/snapshots/my_snapshot` - Local path `file:///qdrant/snapshots/test_collection-2022-08-04-10-49-10.snapshot`", "type" "string", "format" "uri"}, "priority" {"description" "Defines which data should be used as a source of truth if there are other replicas in the cluster. If set to `Snapshot`, the snapshot will be used as a source of truth, and the current state will be overwritten. If set to `Replica`, the current state will be used as a source of truth, and after recovery if will be synchronized with the snapshot.", "default" nil, "anyOf" [{"$ref" "#/components/schemas/SnapshotPriority"} {"nullable" true}]}}}

qdrant:SnapshotRecover a jsonschema:ObjectSchema ;
  jsonschema:required (
    "location"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "location" ;
      rdf:type jsonschema:StringSchema ;
      jsonschema:format "uri" ;
      ]
    [
      jsonschema:propertyName "priority" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:SnapshotPriority
        jsonschema:NullSchema
        ) ;
      ]
    ) .

# StateRole
# {"description" "Role of the peer in the consensus", "type" "string", "enum" ["Follower" "Candidate" "Leader" "PreCandidate"]}

qdrant:StateRole a jsonschema:StringSchema ;
  jsonschema:enum (
    "Follower"
    "Candidate"
    "Leader"
    "PreCandidate"
    ) .

# TelemetryData
# {"type" "object", "required" ["app" "cluster" "collections" "id" "requests"], "properties" {"id" {"type" "string"}, "app" {"$ref" "#/components/schemas/AppBuildTelemetry"}, "collections" {"$ref" "#/components/schemas/CollectionsTelemetry"}, "cluster" {"$ref" "#/components/schemas/ClusterTelemetry"}, "requests" {"$ref" "#/components/schemas/RequestsTelemetry"}}}

qdrant:TelemetryData a jsonschema:ObjectSchema ;
  jsonschema:required (
    "app"
    "cluster"
    "collections"
    "id"
    "requests"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "id" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "app" ;
      rdf:type qdrant:AppBuildTelemetry ;
      ]
    [
      jsonschema:propertyName "collections" ;
      rdf:type qdrant:CollectionsTelemetry ;
      ]
    [
      jsonschema:propertyName "cluster" ;
      rdf:type qdrant:ClusterTelemetry ;
      ]
    [
      jsonschema:propertyName "requests" ;
      rdf:type qdrant:RequestsTelemetry ;
      ]
    ) .

# TextIndexParams
# {"type" "object", "required" ["type"], "properties" {"type" {"$ref" "#/components/schemas/TextIndexType"}, "tokenizer" {"$ref" "#/components/schemas/TokenizerType"}, "min_token_len" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "max_token_len" {"type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "lowercase" {"description" "If true, lowercase all tokens. Default: true", "type" "boolean", "nullable" true}}}

qdrant:TextIndexParams a jsonschema:ObjectSchema ;
  jsonschema:required (
    "type"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "type" ;
      rdf:type qdrant:TextIndexType ;
      ]
    [
      jsonschema:propertyName "tokenizer" ;
      rdf:type qdrant:TokenizerType ;
      ]
    [
      jsonschema:propertyName "min_token_len" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "max_token_len" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      dcterms:description "If true, lowercase all tokens. Default: true" ;
      jsonschema:propertyName "lowercase" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    ) .

# TextIndexType
# {"type" "string", "enum" ["text"]}

qdrant:TextIndexType a jsonschema:StringSchema ;
  jsonschema:enum (
    "text"
    ) .

# TokenizerType
# {"type" "string", "enum" ["prefix" "whitespace" "word"]}

qdrant:TokenizerType a jsonschema:StringSchema ;
  jsonschema:enum (
    "prefix"
    "whitespace"
    "word"
    ) .

# UpdateCollection
# {"description" "Operation for updating parameters of the existing collection", "type" "object", "properties" {"optimizers_config" {"description" "Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete", "anyOf" [{"$ref" "#/components/schemas/OptimizersConfigDiff"} {"nullable" true}]}, "params" {"description" "Collection base params.  If none - values from service configuration file are used.", "anyOf" [{"$ref" "#/components/schemas/CollectionParamsDiff"} {"nullable" true}]}}}

qdrant:UpdateCollection a jsonschema:ObjectSchema ;
  dcterms:description "Operation for updating parameters of the existing collection" ;
  jsonschema:properties (
    [
      jsonschema:propertyName "optimizers_config" ;
      dcterms:description "Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:OptimizersConfigDiff
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "params" ;
      dcterms:description "Collection base params.  If none - values from service configuration file are used." ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:CollectionParamsDiff
        jsonschema:NullSchema
        ) ;
      ]
    ) .

# UpdateResult
# {"type" "object", "required" ["operation_id" "status"], "properties" {"operation_id" {"description" "Sequential number of the operation", "type" "integer", "format" "uint64", "minimum" 0}, "status" {"$ref" "#/components/schemas/UpdateStatus"}}}

qdrant:UpdateResult a jsonschema:ObjectSchema ;
  jsonschema:required (
    "operation_id"
    "status"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "operation_id" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "status" ;
      rdf:type qdrant:UpdateStatus ;
      ]
    ) .

# UpdateStatus
# {"description" "`Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual.", "type" "string", "enum" ["acknowledged" "completed"]}

qdrant:UpdateStatus a jsonschema:StringSchema ;
  dcterms:description "`Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual." ;
  jsonschema:enum (
    "acknowledged"
    "completed"
    ) .

# UpdateVectors
# {"type" "object", "required" ["points"], "properties" {"points" {"description" "Points with named vectors", "type" "array", "items" {"$ref" "#/components/schemas/PointVectors"}, "minItems" 1}}}

qdrant:UpdateVectors a jsonschema:ObjectSchema ;
  jsonschema:required (
    "points"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "points" ;
      dcterms:description "Points with named vectors" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items qdrant:PointVectors ;
      jsonschema:minItems 1 ;
      ]
    ) .

# UsingVector
# {"anyOf" [{"type" "string"}]}

qdrant:UsingVector a jsonschema:DataSchema ;
  jsonschema:anyOf (
    jsonschema:StringSchema
    ) .

# ValueVariants
# {"anyOf" [{"type" "string"} {"type" "integer", "format" "int64"} {"type" "boolean"}]}

qdrant:ValueVariants a jsonschema:DataSchema ;
  jsonschema:anyOf (
    jsonschema:StringSchema
    [ rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "int64" ]
    jsonschema:BooleanSchema
    ) .

# ValuesCount
# {"description" "Values count filter request", "type" "object", "properties" {"lt" {"description" "point.key.length() < values_count.lt", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "gt" {"description" "point.key.length() > values_count.gt", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "gte" {"description" "point.key.length() >= values_count.gte", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}, "lte" {"description" "point.key.length() <= values_count.lte", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:ValuesCount a jsonschema:ObjectSchema ;
  jsonschema:properties (
    [
      jsonschema:propertyName "lt" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "gt" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "gte" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "lte" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# VectorDataConfig
# {"description" "Config of single vector data storage", "type" "object", "required" ["distance" "index" "size" "storage_type"], "properties" {"size" {"description" "Size/dimensionality of the vectors used", "type" "integer", "format" "uint", "minimum" 0}, "distance" {"$ref" "#/components/schemas/Distance"}, "storage_type" {"$ref" "#/components/schemas/VectorStorageType"}, "index" {"$ref" "#/components/schemas/Indexes"}, "quantization_config" {"description" "Vector specific quantization config that overrides collection config", "anyOf" [{"$ref" "#/components/schemas/QuantizationConfig"} {"nullable" true}]}}}

qdrant:VectorDataConfig a jsonschema:ObjectSchema ;
  dcterms:description "Config of single vector data storage" ;
  jsonschema:required (
    "distance"
    "index"
    "size"
    "storage_type"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "size" ;
      dcterms:description "Size/dimensionality of the vectors used" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    [
      jsonschema:propertyName "distance" ;
      rdf:type qdrant:Distance ;
      ]
    [
      jsonschema:propertyName "storage_type" ;
      rdf:type qdrant:VectorStorageType ;
      ]
    [
      jsonschema:propertyName "index" ;
      rdf:type qdrant:Indexes ;
      ]
    [
      jsonschema:propertyName "quantization_config" ;
      dcterms:description "Vector specific quantization config that overrides collection config" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:QuantizationConfig
        jsonschema:NullSchema
        ) ;
      ]
    ) .

# VectorIndexSearchesTelemetry
# {"type" "object", "required" ["filtered_exact" "filtered_large_cardinality" "filtered_plain" "filtered_small_cardinality" "unfiltered_exact" "unfiltered_hnsw" "unfiltered_plain"], "properties" {"index_name" {"type" "string", "nullable" true}, "unfiltered_plain" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "unfiltered_hnsw" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "filtered_plain" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "filtered_small_cardinality" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "filtered_large_cardinality" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "filtered_exact" {"$ref" "#/components/schemas/OperationDurationStatistics"}, "unfiltered_exact" {"$ref" "#/components/schemas/OperationDurationStatistics"}}}

qdrant:VectorIndexSearchesTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "filtered_exact"
    "filtered_large_cardinality"
    "filtered_plain"
    "filtered_small_cardinality"
    "unfiltered_exact"
    "unfiltered_hnsw"
    "unfiltered_plain"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "index_name" ;
      rdf:type jsonschema:StringSchema ;
      ]
    [
      jsonschema:propertyName "unfiltered_plain" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "unfiltered_hnsw" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "filtered_plain" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "filtered_small_cardinality" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "filtered_large_cardinality" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "filtered_exact" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    [
      jsonschema:propertyName "unfiltered_exact" ;
      rdf:type qdrant:OperationDurationStatistics ;
      ]
    ) .

# VectorParams
# {"description" "Params of single vector data storage", "type" "object", "required" ["distance" "size"], "properties" {"size" {"description" "Size of a vectors used", "type" "integer", "format" "uint64", "minimum" 1}, "distance" {"$ref" "#/components/schemas/Distance"}, "hnsw_config" {"description" "Custom params for HNSW index. If none - values from collection configuration are used.", "anyOf" [{"$ref" "#/components/schemas/HnswConfigDiff"} {"nullable" true}]}, "quantization_config" {"description" "Custom params for quantization. If none - values from collection configuration are used.", "anyOf" [{"$ref" "#/components/schemas/QuantizationConfig"} {"nullable" true}]}, "on_disk" {"description" "If true, vectors are served from disk, improving RAM usage at the cost of latency Default: false", "type" "boolean", "nullable" true}}}

qdrant:VectorParams a jsonschema:ObjectSchema ;
  dcterms:description "Params of single vector data storage" ;
  jsonschema:required (
    "distance"
    "size"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "size" ;
      dcterms:description "Size of a vectors used" ;
      rdf:type jsonschema:IntegerSchema ;
      jsonschema:format "uint64" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "distance" ;
      rdf:type qdrant:Distance ;
      ]
    [
      jsonschema:propertyName "hnsw_config" ;
      dcterms:description "Custom params for HNSW index. If none - values from collection configuration are used." ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:HnswConfigDiff
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "quantization_config" ;
      dcterms:description "Custom params for quantization. If none - values from collection configuration are used." ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:anyOf (
        qdrant:QuantizationConfig
        jsonschema:NullSchema
        ) ;
      ]
    [
      jsonschema:propertyName "on_disk" ;
      dcterms:description "If true, vectors are served from disk, improving RAM usage at the cost of latency Default: false" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    ) .

# VectorStorageType
# {"description" "Storage types for vectors", "oneOf" [{"description" "Storage in memory (RAM)\n\nWill be very fast at the cost of consuming a lot of memory.", "type" "string", "enum" ["Memory"]} {"description" "Storage in mmap file, not appendable\n\nSearch performance is defined by disk speed and the fraction of vectors that fit in memory.", "type" "string", "enum" ["Mmap"]} {"description" "Storage in chunked mmap files, appendable\n\nSearch performance is defined by disk speed and the fraction of vectors that fit in memory.", "type" "string", "enum" ["ChunkedMmap"]}]}

qdrant:VectorStorageType a jsonschema:StringSchema ;
  dcterms:description "Storage types for vectors" ;
  jsonschema:oneOf (
    [
      rdf:type jsonschema:StringSchema ;
      jsonschema:enum "Memory" ;
      dcterms:description "Storage in memory (RAM). Will be very fast at the cost of consuming a lot of memory." ;
      ]
    [
      rdf:type jsonschema:StringSchema ;
      jsonschema:enum "Mmap" ;
      dcterms:description "Storage in mmap file, not appendable. Search performance is defined by disk speed and the fraction of vectors that fit in memory." ;
      ]
    [
      rdf:type jsonschema:StringSchema ;
      jsonschema:enum "ChunkedMmap" ;
      dcterms:description "Storage in chunked mmap files, appendable. Search performance is defined by disk speed and the fraction of vectors that fit in memory." ;
      ]
    ) .

# VectorStruct
# {"description" "Full vector data per point separator with single and multiple vector modes", "anyOf" [{"type" "array", "items" {"type" "number", "format" "float"}} {"type" "object", "additionalProperties" {"type" "array", "items" {"type" "number", "format" "float"}}}]}

qdrant:VectorStruct a jsonschema:DataSchema ;
  dcterms:description "Full vector data per point separator with single and multiple vector modes" ;
  jsonschema:anyOf (
    [
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        [
          rdf:type jsonschema:NumberSchema ;
          jsonschema:format "float" ;
          ]
        ) ;
      ]
    [
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:properties (
        [
          rdf:type jsonschema:ArraySchema ;
          jsonschema:items (
            [
              rdf:type jsonschema:NumberSchema ;
              jsonschema:format "float" ;
              ]
            ) ;
          ]
        ) ;
      ]
    ) .

# VectorsConfig
# {"description" "Vector params separator for single and multiple vector modes Single mode:\n\n{ \"size\": 128, \"distance\": \"Cosine\" }\n\nor multiple mode:\n\n{ \"default\": { \"size\": 128, \"distance\": \"Cosine\" } }", "anyOf" [{"$ref" "#/components/schemas/VectorParams"} {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/VectorParams"}}]}

qdrant:VectorsConfig a jsonschema:DataSchema ;
  dcterms:description "Vector params separator for single and multiple vector modes Single mode:\n\n{ \"size\": 128, \"distance\": \"Cosine\" }\n\nor multiple mode:\n\n{ \"default\": { \"size\": 128, \"distance\": \"Cosine\" } }" ;
  jsonschema:anyOf (
    [
      rdf:type qdrant:VectorParams ;
      ]
    [
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:properties (
        [
          rdf:type qdrant:VectorParams ;
          ]
        ) ;
      ]
    ) .

# WalConfig
# {"type" "object", "required" ["wal_capacity_mb" "wal_segments_ahead"], "properties" {"wal_capacity_mb" {"description" "Size of a single WAL segment in MB", "type" "integer", "format" "uint", "minimum" 1}, "wal_segments_ahead" {"description" "Number of WAL segments to create ahead of actually used ones", "type" "integer", "format" "uint", "minimum" 0}}}

qdrant:WalConfig a jsonschema:ObjectSchema ;
  jsonschema:required (
    "wal_capacity_mb" "wal_segments_ahead"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "wal_capacity_mb" ;
      dcterms:description "Size of a single WAL segment in MB" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "wal_segments_ahead" ;
      dcterms:description "Number of WAL segments to create ahead of actually used ones" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# WalConfigDiff
# {"type" "object", "properties" {"wal_capacity_mb" {"description" "Size of a single WAL segment in MB", "type" "integer", "format" "uint", "minimum" 1, "nullable" true}, "wal_segments_ahead" {"description" "Number of WAL segments to create ahead of actually used ones", "type" "integer", "format" "uint", "minimum" 0, "nullable" true}}}

qdrant:WalConfigDiff a jsonschema:ObjectSchema ;
  jsonschema:properties (
    [
      jsonschema:propertyName "wal_capacity_mb" ;
      dcterms:description "Size of a single WAL segment in MB" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 1 ;
      ]
    [
      jsonschema:propertyName "wal_segments_ahead" ;
      dcterms:description "Number of WAL segments to create ahead of actually used ones" ;
      rdf:type jsonschema:NumberSchema ;
      jsonschema:format "uint" ;
      jsonschema:minimum 0 ;
      ]
    ) .

# WebApiTelemetry
# {"type" "object", "required" ["responses"], "properties" {"responses" {"type" "object", "additionalProperties" {"type" "object", "additionalProperties" {"$ref" "#/components/schemas/OperationDurationStatistics"}}}}}

qdrant:WebApiTelemetry a jsonschema:ObjectSchema ;
  jsonschema:required (
    "responses"
    ) ;
  jsonschema:properties (
    [
      jsonschema:propertyName "responses" ;
      rdf:type jsonschema:ObjectSchema ;
      jsonschema:properties [
              rdf:type qdrant:OperationDurationStatistics ;
              ] ;
      ]
    ) .

# WithPayloadInterface
# {"description" "Options for specifying which payload to include or not", "anyOf" [{"description" "If `true` - return all payload, If `false` - do not return payload", "type" "boolean"} {"description" "Specify which fields to return", "type" "array", "items" {"type" "string"}} {"$ref" "#/components/schemas/PayloadSelector"}]}

qdrant:WithPayloadInterface a jsonschema:DataSchema ;
  dcterms:description "Options for specifying which payload to include or not" ;
  jsonschema:anyOf (
    [
      jsonschema:propertyName "include_payload" ;
      dcterms:description "If `true` - return all payload, If `false` - do not return payload" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "fields" ;
      dcterms:description "Specify which fields to return" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        [
          rdf:type jsonschema:StringSchema ;
          ]
        ) ;
      ]
    qdrant:PayloadSelector
    ) .

# WithVector
# {"description" "Options for specifying which vector to include", "anyOf" [{"description" "If `true` - return all vector, If `false` - do not return vector", "type" "boolean"} {"description" "Specify which vector to return", "type" "array", "items" {"type" "string"}}]}

qdrant:WithVector a jsonschema:DataSchema ;
  dcterms:description "Options for specifying which vector to include" ;
  jsonschema:anyOf (
    [
      jsonschema:propertyName "include_vector" ;
      dcterms:description "If `true` - return all vector, If `false` - do not return vector" ;
      rdf:type jsonschema:BooleanSchema ;
      ]
    [
      jsonschema:propertyName "fields" ;
      dcterms:description "Specify which vector to return" ;
      rdf:type jsonschema:ArraySchema ;
      jsonschema:items (
        [
          rdf:type jsonschema:StringSchema ;
          ]
        ) ;
      ]
    ) .

# WriteOrdering
# {"description" "Defines write ordering guarantees for collection operations\n\n* `weak` - write operations may be reordered, works faster, default\n\n* `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change\n\n* `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down", "type" "string", "enum" ["weak" "medium" "strong"]}

qdrant:WriteOrdering a jsonschema:StringSchema ;
  dcterms:description "Defines write ordering guarantees for collection operations\n\n* `weak` - write operations may be reordered, works faster, default\n\n* `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change\n\n* `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down" ;
  jsonschema:enum (
    "weak" "medium" "strong"
    ) .
